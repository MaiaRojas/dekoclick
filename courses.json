{
  "functional": {
    "order": 10,
    "title": "Functional JavaScript",
    "description": "<p>En este curso exploraremos el paradigma funcional en JavaScript as&#xED; como varios\npatrones, t&#xE9;cnicas y convenciones asociadas a este paradigma, haciendo uso de\nlas nuevas caracter&#xED;sticas de ES2015.</p>\n<p>La programaci&#xF3;n funcional es un paradigma de programaci&#xF3;n de suma relevancia hoy\nen d&#xED;a, ya que se presta a resolver problemas de paralelizaci&#xF3;n, asincron&#xED;a y\nprogramaci&#xF3;n reactiva entre otros. La programaci&#xF3;n funcional (<em>Functional\nProgramming</em> o FP por sus siglas en ingl&#xE9;s) no es realmente un paradigma nuevo,\nexiste desde hace medio siglo, pero recientemente, y en particular en el mundo\nde JavaScript, se ha convertido en tanto una moda como una necesidad. Poco a\npoco, desde la proliferaci&#xF3;n de librer&#xED;as como <a href=\"http://underscorejs.org/\">underscore</a> y <a href=\"https://lodash.com/\">lodash</a>,\ndespu&#xE9;s la adici&#xF3;n de <code>map()</code>, <code>filter()</code>, <code>reduce()</code> y compa&#xF1;&#xED;a, y ahora con\n<em>frameworks</em> como <a href=\"https://facebook.github.io/react/\">React</a> y <a href=\"http://redux.js.org/\">Redux</a>, conocer el paradigma funcional y estilo\ndeclarativo se han convertido en una necesidad para cualquier desarrollador de\nJavaScript.</p>\n<p>Familiarizarnos con la programci&#xF3;n funcional en JavaScript y ES2015 nos\npermitir&#xE1; m&#xE1;s adelante desenvolvernos con naturalidad en React.</p>\n\n",
    "tags": {
      "primary": [
        "functional",
        "es6"
      ],
      "secondary": []
    },
    "targetAudience": "<p>Este curso está dirigido a desarrolladoras tanto <em>front-end</em> como <em>back-end</em>.\nJavaScript es un lenguaje de naturaleza funcional. En este curso aprenderás\nsobre los principios de la programación funcional y cómo se reflejan en\nJavaScript moderno.</p>\n",
    "dependencies": "<p>Para poder llevar adelante este curso sin frustración, es recomendable los\nsiguientes conocimientos previos:</p>\n<ul>\n<li>Manejo de línea de comandos (*nix) y <code>git</code></li>\n<li>Manejo básico de <code>npm</code></li>\n<li>Debes haber completado el curso de <a href=\"https://github.com/Laboratoria/curricula-js/tree/master/09-paradigms\">paradigmas de programación</a>.</li>\n</ul>\n",
    "learningObjectives": "<ul>\n<li>ES2015</li>\n<li>Funciones puras</li>\n<li>Inmutabilidad</li>\n<li>Recursión</li>\n<li><em>Higher Order Functions</em></li>\n<li>Composición de funciones</li>\n<li>Refactorización</li>\n<li>Trabajo en equipo</li>\n<li>Revisión en pares o <em>Peer-review</em></li>\n<li>Github issues, branches, pull requests, entre otros.</li>\n</ul>\n",
    "product": "<ul>\n<li>Refactorizar juego usado en lección 9 usando principios de programación\nfuncional, ES6 y añadiendo un conjunto de pruebas.</li>\n<li>El &quot;proyecto&quot; está basado en iterar una aplicación existente y llevar a cabo\nsu siguiente release usando metodología ágil.</li>\n</ul>\n",
    "syllabus": {
      "01-state": {
        "title": "Evitando el estado compartido y cambiante",
        "bonus": false,
        "description": "<p>En esta unidad veremos dos de los principios fundamentales de la programación\nfuncional: cómo evitar el estado compartido usando <strong>funciones puras</strong> y el\nconcepto de <strong>inmutabilidad</strong>. La duración estimada de esta unidad es de <em>3h</em>.</p>\n",
        "parts": {
          "00-opening": {
            "title": "Apertura",
            "type": "seminario",
            "format": "guiado",
            "duration": 15,
            "body": "<h2 id=\"-por-qu-aprender-esto-\">&#xBF;Por qu&#xE9; aprender esto?</h2>\n<p>En esta unidad veremos dos de los principios fundamentales de la programaci&#xF3;n\nfuncional: c&#xF3;mo evitar el estado compartido usando <strong>funciones puras</strong> y el\nconcepto de <strong>inmutabilidad</strong>. Ambos conceptos son esenciales en el paradigma\nfuncional y su uso presenta un mont&#xF3;n de beneficios, a veces sutiles, pero muy\nimportantes.</p>\n<ul>\n<li>Representan bloques de c&#xF3;digo reusable dentro de un programa.</li>\n<li>Promueven buenas pr&#xE1;cticas de desarrollo como [DRY][]\n(<em>Don&#x2019;t Repeat Yourself</em>) y [KISS][] (<em>Keep It Simple, Stupid</em>).</li>\n<li>Al no depender del contexto externo, son inmunes a toda clase de errores o\n<em>bugs</em> que tienen que ver con el estado mutable compartido.</li>\n<li>Su naturaleza independiente las hace excelentes candidatos para procesamiento\nconcurrente a lo largo de muchos CPUs e incluso para la computaci&#xF3;n\ndistribuida, lo cual las hace esenciales para la ejecuci&#xF3;n de tareas de\nc&#xE1;lculo cient&#xED;fico y de uso intensivo de recursos.</li>\n<li>Su aislamiento facilita la refactorizaci&#xF3;n y reorganizaci&#xF3;n del c&#xF3;digo,\nhaciendo t&#xFA; c&#xF3;digo m&#xE1;s adaptable y flexible a futuros cambios.</li>\n<li>Es mucho m&#xE1;s sencillo el desarrollo de pruebas unitarias contra funciones\npuras.</li>\n<li>Las funciones puras representan la base de la programaci&#xF3;n funcional.</li>\n</ul>\n<h2 id=\"entregables-y-evaluaci-n\">Entregables y evaluaci&#xF3;n</h2>\n<ul>\n<li><strong>Ejercicios</strong>: Durante esta unidad completar&#xE1;s varios ejercicios en el LMS.\nEstos ejercicios incluyen tests automatizados con la intenci&#xF3;n de dar feedback\nimmediato, pero los ejercicios en s&#xED; no ser&#xE1;n calificados. Se elegir&#xE1; uno o\ndos ejercicios junto con el proyecto para la sesi&#xF3;n de <em>code review</em>, que s&#xED;\nser&#xE1; calificada.</li>\n<li><strong>Cuestionarios</strong>: Al igual que los ejercicios, a lo largo de la unidad\nresponder&#xE1;s varios cuestionarios con feedback immediato, y &#xE9;stos no cuentan\npara la nota final.</li>\n</ul>\n<h2 id=\"hoja-de-ruta\">Hoja de ruta</h2>\n<h3 id=\"semana-1\">Semana 1</h3>\n<ul>\n<li><strong>Sesi&#xF3;n 1: presencial 3h =&gt; Funciones puras e inmutabilidad</strong></li>\n<li>Sesi&#xF3;n 2: self-paced 2h =&gt; Refactorizar <code>Loader</code></li>\n</ul>\n<h3 id=\"semana-2\">Semana 2</h3>\n<ul>\n<li>Pre-tarea: Lectura <em>Higher Order Functions</em> (Unidad 03)</li>\n<li>Sesi&#xF3;n 3: presencial 3h =&gt; Higher Order Functions</li>\n<li>Sesi&#xF3;n 4: self-paced 2h =&gt; Refactorizar ???</li>\n</ul>\n<h3 id=\"semana-3\">Semana 3</h3>\n<ul>\n<li>Pre-tarea: Lectura <em>Recursividad</em> (Unidad 05)</li>\n<li>Sesi&#xF3;n 5: presencial 3h =&gt; Control de flujo (recursi&#xF3;n y asincron&#xED;a)</li>\n<li>Sesi&#xF3;n 6: self-paced 2h =&gt; Refactorizar ???</li>\n</ul>\n<h3 id=\"semana-4\">Semana 4</h3>\n<ul>\n<li>Pre-tarea: Implementaci&#xF3;n, refactoring, pull request</li>\n<li>Sesi&#xF3;n 7: presencial 3h =&gt; Code review + Demos de proyectos</li>\n<li>Sesi&#xF3;n 8: self-paced 2h =&gt; Retrospectiva</li>\n</ul>\n<h2 id=\"gu-a-de-preguntas-y-conceptos-clave\">Gu&#xED;a de preguntas y conceptos clave</h2>\n<p>Cuando empezamos a estudiar un tema nuevo, es &#xFA;til tener una idea de los\nconceptos m&#xE1;s importantes de lo que vamos a aprender y de los temas centrales\nque debemos prestar particular atenci&#xF3;n.</p>\n<p>A continuaci&#xF3;n te presentamos una serie de preguntas que debes ser capaz de\nresponder al terminar esta unidad. Utiliza estas preguntas como gu&#xED;a para\norientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida\nque avanzas para validar que est&#xE1;s avanzando en la direcci&#xF3;n correcta. Que te\nsirva como un &quot;checklist&quot; que vas marcando a medida que vas progresando.</p>\n<ul>\n<li>C&#xF3;mo evitar que nuestras funciones tengan efectos colaterales?</li>\n<li>Por qu&#xE9; es beneficioso evitar el estado compartido?</li>\n<li>Cu&#xE1;les son las ventajas que ofrecen las funciones puras, en particular a la\nhora de hacer testing?</li>\n<li>C&#xF3;mo evitar la mutaci&#xF3;n de objetos y arreglos?</li>\n<li>Qu&#xE9; tipos de datos son mutables e inmutables en JavaScript?</li>\n<li>C&#xF3;mo usar m&#xE9;todos de arreglos como <code>Array#concat</code>, <code>Array#slice</code>, <code>Array#map</code>,\n<code>Array#filter</code>, ... para crear arreglos nuevos en vez de mutar (modificar)\nvalores existentes?</li>\n<li>C&#xF3;mo usar m&#xE9;todos de objetos (por ejemplo <code>Object.assign()</code>) para copiar\npropiedades y as&#xED; <em>clonar</em> objetos?</li>\n<li>C&#xF3;mo usar el <em>spread operator</em> (<code>...</code>) para copiar objetos y arreglos?</li>\n</ul>\n"
          },
          "01-pure-fun": {
            "title": "Funciones puras",
            "type": "lectura",
            "format": "self-paced",
            "duration": 30,
            "body": "<p>Las funciones puras tienen aplicaciones en muchos &#xE1;mbitos, entre ellos la\nprogramaci&#xF3;n funcional. Tambi&#xE9;n facilitan la concurrencia, y como veremos en\nsiguientes etapas ser&#xE1;n muy empleadas en aplicaciones basadas en React+Redux.</p>\n<p>Anteriormente mencionamos que una funci&#xF3;n es b&#xE1;sicamente un proceso que toma una\nentrada o argumentos, y produce una salida o valor de retorno. Tambi&#xE9;n hemos\nvisto que las funciones se emplean con ciertos prop&#xF3;sitos:</p>\n<ul>\n<li><em>Manipulaci&#xF3;n de datos:</em> Transforma una serie de argumentos o entrada en un\nvalor de retorno. Un ejemplo de esto ser&#xED;a hacer <em>flattening</em><sup>1</sup> de\nun objeto muy anidado.</li>\n<li><em>Procedimientos:</em> Una funci&#xF3;n puede ser llamada para realizar una serie de\npasos (receta). <strong>La secuencia es conocida como procedimiento</strong> (primero haz\nesto, luego haz aquello), el estilo de programaci&#xF3;n bajo este estilo se\ndenomina <strong>programaci&#xF3;n por procedimientos</strong>, la cual est&#xE1; enmarcada en la\n<strong>programaci&#xF3;n imperativa</strong>, donde se usan sentencias que modifican o mutan el\nestado del programa, de la misma forma en la que mandatos imperativos expresan\ncomandos en nuestro lenguaje natural, un programa imperativo consiste en\ncomandos que la computadora debe realizar. La programaci&#xF3;n imperativa se\nenfoca en describir <em>c&#xF3;mo</em> un programa opera, mientras que en la programaci&#xF3;n\nfuncional nos enfocamos en <em>qu&#xE9;</em> debe realizar un programa sin especificar\n<em>c&#xF3;mo</em> dicho programa debe alcanzar el resultado.</li>\n<li><em>Entrada/Salida:</em> Algunas funciones existen para comunicarse con otras partes\no subsistemas, por ejemplo: la pantalla, almacenamiento, registro de\noperaciones en disco, operaciones a trav&#xE9;s de la red.</li>\n</ul>\n<p>Una vez vistas las diversas aplicaciones de las funciones procedamos a dejar\nclaro que significa una <em>funci&#xF3;n pura</em>.</p>\n<blockquote>\n<p>Toda funci&#xF3;n que dados los mismos inputs siempre retorna lo mismo, y sin\nefectos secundarios, es una <em>funci&#xF3;n pura</em>.</p>\n</blockquote>\n<p>En <strong>programaci&#xF3;n funcional</strong>, el comportamiento de las funciones depende de una\ny solo una cosa: los argumentos pasados expl&#xED;citamente a la funci&#xF3;n. Esto quiere\ndecir que si proporcionas los mismos datos como argumentos o entrada, la funci&#xF3;n\nsiempre debe producir el mismo valor de retorno. A esta propiedad se le conoce\ncomo <strong>transparencia referencial</strong>.</p>\n<p>Lo mencionado en el p&#xE1;rrafo anterior, hace que en las funciones puras sea m&#xE1;s\nf&#xE1;cil apreciar todas las circunstancias que pueden presentarse, incluyendo\naquellos escenarios que resultan en errores. Escribir funciones que solo\ndependen de sus argumentos para definir su comportamiento tambi&#xE9;n facilita\nreplicar <em>bugs</em> o poner en pr&#xE1;ctica <em>Test-Driven Development</em> (TDD por sus\nsiglas en ingl&#xE9;s).</p>\n<p>Comencemos desarrollando nuestros casos de pruebas:</p>\n<p><strong>lowercaser.test.js.</strong></p>\n<pre><code class=\"lang-js\">const lowerCaser = require(&apos;./lowercaser&apos;)\n\ntest(&apos;Should take an input string and returns it lowercased&apos;, () =&gt; {\n  expect(lowerCaser(&apos;LOREM IPSUM&apos;)).toBe(&apos;lorem ipsum&apos;)\n})\n</code></pre>\n<hr>\n<p>NOTA:</p>\n<p>A lo largo del curso usaremos <a href=\"https://facebook.github.io/jest/\" target=\"_blank\">Jest</a> como <em>framework</em> para la ejecuci&#xF3;n de\npruebas unitarias. Puedes instalar <strong>Jest</strong> por medio de <code>npm</code> al ejecutar el\nsiguiente comando:</p>\n<pre><code class=\"lang-sh\">npm install --save-dev jest\n</code></pre>\n<p>O tambi&#xE9;n puedes usar <code>yarn</code> al ejecutar:</p>\n<pre><code class=\"lang-sh\">yarn add --dev jest\n</code></pre>\n<p>Para correr las pruebas haremos:</p>\n<pre><code class=\"lang-sh\">yarn run jest -- fichero.test.js\n</code></pre>\n<hr>\n<p>Ahora, pasemos a implementar lo especificado en nuestros casos de pruebas:</p>\n<p><strong>lowercaser.js.</strong></p>\n<pre><code class=\"lang-js\">const lowerCaser = input =&gt; input.toString().toLowerCase()\n\nmodule.exports = lowerCaser\n</code></pre>\n<p>Una vez completada nuestra implementaci&#xF3;n inicial, corroboremos nuestro trabajo\npor medio de la ejecuci&#xF3;n de las pruebas:</p>\n<pre><code class=\"lang-sh\">$ yarn run jest -- lowercaser.test.js\n\nPASS  ./lowercaser.test.js\n   &#x2713; Should take an input string and returns it lowercased (15ms)\n\n   Test Suites: 1 passed, 1 total\n   Tests:       1 passed, 1 total\n   Snapshots:   0 total\n   Time:        0.859s, estimated 1s\n   Ran all test suites matching &quot;lowercaser.test.js&quot;.\n</code></pre>\n<p>Parece que todo funciona como se espera. Continuemos.</p>\n<h2 id=\"dada-la-misma-entrada-devuelve-siempre-la-misma-salida\">Dada la misma entrada, devuelve siempre la misma salida</h2>\n<p>Con nuestra funci&#xF3;n <code>lowerCaser()</code>, podemos reemplazar la llamada de la funci&#xF3;n\npor el resultado, y el c&#xF3;digo tendr&#xE1; el mismo significado <code>lowerCaser(&apos;LOREM\nIPSUM&apos;)</code> siempre ser&#xE1; lo mismo que <code>lorem ipsum</code> en su programa, sin importar el\ncontexto, cu&#xE1;ntas veces lo llame o cu&#xE1;ndo lo llame.</p>\n<p>Pero no se puede decir lo mismo de todas las funciones. Algunas funciones se\nbasan en informaci&#xF3;n distinta de los argumentos que se transmiten para producir\nresultados. Considera este ejemplo:</p>\n<pre><code class=\"lang-js\">Math.random() // =&gt; 0.4011148700956255\nMath.random() // =&gt; 0.8533405303023756\nMath.random() // =&gt; 0.3550692005082965\n</code></pre>\n<p>A pesar de que no pasamos ning&#xFA;n argumento en ninguna de las llamadas a la\nfunci&#xF3;n, todos produjeron resultados diferentes, lo que significa que\n<code>Math.random()</code> <strong>no es una funci&#xF3;n pura</strong>. <code>Math.random()</code> produce un nuevo\nn&#xFA;mero aleatorio entre 0 y 1 cada vez que lo ejecutas, entonces es obvio que no\nse podr&#xED;a simplemente reemplazarlo por <code>0.4011148700956255</code> sin cambiar el\nsignificado del programa.</p>\n<p>Eso producir&#xED;a el mismo resultado cada vez que se ejecute el programa. Cuando le\npedimos a la computadora un n&#xFA;mero aleatorio, por lo general significa que\nqueremos un resultado diferente al que obtuvimos la &#xFA;ltima vez. &#xBF;Cu&#xE1;l es el\nsentido de un par de dados con los mismos n&#xFA;meros impresos en todas las caras? A\nveces tenemos que preguntarle a la computadora por la hora actual. No vamos a\nentrar en detalles de c&#xF3;mo funcionan las funciones de tiempo. Por ahora,\nsimplemente copia este c&#xF3;digo:</p>\n<pre><code class=\"lang-js\">const time = () =&gt; new Date().toLocaleTimeString()\ntime() // =&gt; &quot;5:15:45 PM&quot;\n</code></pre>\n<p>&#xBF;Qu&#xE9; suceder&#xED;a si reemplazo la llamada de la funci&#xF3;n <code>time()</code> con la hora\nactual? Siempre dir&#xED;a que es la misma hora: la hora con la cual la llamada a la\nfunci&#xF3;n se reemplaz&#xF3;. En otras palabras, solo podr&#xED;a producir la salida correcta\nuna vez al d&#xED;a, y solo si se ejecuta el programa en el momento exacto en que la\nhora se reemplaz&#xF3; por la funci&#xF3;n.</p>\n<p>Entonces, claramente, <code>time()</code> no es como la funci&#xF3;n <code>lowerCaser()</code>.</p>\n<p>Una funci&#xF3;n solo es pura si, dada la misma entrada, siempre producir&#xE1; la misma\nsalida. Tal vez recuerdes esta regla de la clase de &#xE1;lgebra: los mismos valores\nde entrada se asignar&#xE1;n siempre al mismo valor de salida. Sin embargo, muchos\nvalores de entrada se pueden asignar al mismo valor de salida. Por ejemplo, la\nsiguiente funci&#xF3;n es pura:</p>\n<pre><code class=\"lang-js\">const highpass = (cutoff, value) =&gt; value &gt;= cutoff;\n</code></pre>\n<p>Los mismos valores de entrada se asignar&#xE1;n siempre al mismo valor de salida:</p>\n<pre><code class=\"lang-js\">highpass(5, 5) // =&gt; true\nhighpass(5, 5) // =&gt; true\nhighpass(5, 5) // =&gt; true\n</code></pre>\n<p>Muchos valores de entrada tal vez se pueden asignar al mismo valor de salida:</p>\n<pre><code class=\"lang-js\">highpass(5, 123) // true\nhighpass(5, 6)   // true\nhighpass(5, 18)  // true\nhighpass(5, 1)   // false\nhighpass(5, 3)   // false\nhighpass(5, 4)   // false\n</code></pre>\n<h2 id=\"efectos-colaterales\">Efectos colaterales</h2>\n<p>En este punto cabe aclarar que las funciones puras no producen <strong>efectos\ncolaterales</strong> o <em>side-effects</em>, pues el prop&#xF3;sito de vida de una funci&#xF3;n pura es\n&#xFA;nicamente calcular el valor de retorno, solo eso y nada m&#xE1;s.</p>\n<p>En las ciencias de la computaci&#xF3;n, una funci&#xF3;n o expresi&#xF3;n se dice que tiene\nefectos colaterales si modifica alg&#xFA;n estado fuera de su &#xE1;mbito (<em>scope</em>), o si\ntiene interacciones observables con la funci&#xF3;n que la invoc&#xF3;, o si modifica el\nmundo exterior aparte de retornar el valor esperado. Por ejemplo, una funci&#xF3;n\nparticular podr&#xED;a modificar una variable global (estado fuera de su &#xE1;mbito),\nmodificar uno de los argumentos mutables (interactuar con la funci&#xF3;n la invoc&#xF3;),\nlevantar una excepci&#xF3;n, escribir datos a un fichero o llamar a otra funci&#xF3;n que\nsi tiene efectos colaterales. Ten en cuenta que ante la presencia de funciones\ncon efectos colaterales, el comportamiento de un programa podr&#xED;a depender de su\nhistoria, esto quiere decir que el orden de evaluaci&#xF3;n importa. Por lo tanto, la\ncomprensi&#xF3;n y an&#xE1;lisis de una funci&#xF3;n con efectos colaterales requiere\nconocimientos acerca de su contexto y su posible historia, lo cual hace m&#xE1;s\ndif&#xED;cil la correcci&#xF3;n de errores. En la programaci&#xF3;n funcional, los efectos\ncolaterales se usan con moderaci&#xF3;n.</p>\n<p>Veamos un ejemplo de efecto colateral y c&#xF3;mo podemos evitarlo.</p>\n<p>Supongamos que deseamos crear una funci&#xF3;n que concatene dos <em>arrays</em> que pueden\ncontener elementos anidados, tratemos de emular el siguiente comportamiento:</p>\n<p><strong>concat.test.js.</strong></p>\n<pre><code class=\"lang-js\">const concat = require(&apos;./concat&apos;)\n\ntest(&apos;should concatenate array on the right with array on the left&apos;, () =&gt; {\n  const left = [1, [2], 3]\n  const right = [[4], 5, [6, 7], 8]\n  const expected = [1, [2], 3, [4], 5, [6, 7], 8]\n\n  expect(concat(left, right)).toEqual(expected)\n})\n</code></pre>\n<p>Una implementaci&#xF3;n inicial puede ser la siguiente:</p>\n<p><strong>concat.js.</strong></p>\n<pre><code class=\"lang-js\">const concat = (left, right) =&gt; {\n  const result = left\n\n  right.map(item =&gt; {\n    result.push(item)\n  })\n\n  return result\n}\n\nmodule.exports = concat\n</code></pre>\n<blockquote>\n<p><strong>Nota</strong></p>\n<p>Ten en cuenta que esta implementaci&#xF3;n es a modo de ejemplo, en realidad\npodr&#xED;amos usar <a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/concat\" target=\"_blank\">Array.prototype.concat()</a> directamente.</p>\n</blockquote>\n<p>Comprobemos nuestro trabajo:</p>\n<pre><code class=\"lang-sh\">$ yarn run jest -- concat.test.js\n\n PASS  ./concat.test.js\n   &#x2713; should concatenate the array on the right with the array on the left (3ms)\n\n   Test Suites: 1 passed, 1 total\n   Tests:       1 passed, 1 total\n   Snapshots:   0 total\n   Time:        0.67s, estimated 1s\n   Ran all test suites matching &quot;concat.test.js&quot;.\n</code></pre>\n<p>Todo parece indicar que nuestra funci&#xF3;n tiene un comportamiento correcto, ahora\nagreguemos un caso de prueba para comprobar que no estamos alterando el contexto\nexterno:</p>\n<p><strong>concat.test.js.</strong></p>\n<pre><code class=\"lang-js\">const concat = require(&apos;./concat&apos;)\n\ntest(&apos;should concatenate array on the right with array on the left&apos;, () =&gt; {\n  const left = [1, [2], 3]\n  const right = [[4], 5, [6, 7], 8]\n  const expected = [1, [2], 3, [4], 5, [6, 7], 8]\n\n  expect(concat(left, right)).toEqual(expected)\n})\n\ntest(&apos;should not mutate external context&apos;, () =&gt; {\n  const left = [1, [2], 3]\n  const right = [[4], 5, [6, 7], 8]\n  const backup = Object.assign([], left)\n\n  concat(left, right)\n\n  expect(left).toEqual(backup)\n})\n</code></pre>\n<p>Al ejecutar las pruebas obtenemos lo siguiente:</p>\n<pre><code class=\"lang-sh\">$ yarn run jest -- concat.test.js\n FAIL  ./concat.test.js\n  &#x25CF; should not mutate external context\n\n    expect(received).toEqual(expected)\n\n    Expected value to equal:\n      [1, [2], 3]\n    Received:\n      [1, [2], 3, [4], 5, [6, 7], 8]\n\n  ...\n\n  &#x2713; should concatenate the array on the right with the array on the left (4ms)\n  &#x2715; should not mutate external context (6ms)\n\nTest Suites: 1 failed, 1 total\nTests:       1 failed, 1 passed, 2 total\nSnapshots:   0 total\nTime:        1.011s\nRan all test suites matching &quot;concat.test.js&quot;.\n</code></pre>\n<p><strong>Ouch!</strong>, con esto se demuestra que nuestra <strong>funci&#xF3;n no es pura</strong>, pues\nestamos alterando el contexto externo, lo cual es un tipo de efecto colateral.</p>\n<p>El comportamiento anterior sucede porque los objetos o arreglos pasados a las\nfunciones como argumento se pasan por referencia, no por copia, lo que significa\nque si una funci&#xF3;n muta una propiedad en un objeto o arreglo, supondr&#xED;a que\ndicha mutaci&#xF3;n ser&#xED;a accesible desde afuera de la funci&#xF3;n. Las funciones puras\nno deben alterar el estado externo.</p>\n<p>Si bien el valor de retorno de nuestra funci&#xF3;n es el esperado, el problema con\nla implementaci&#xF3;n actual es que hemos mutado un estado compartido. Imagina por\nun momento que otras funciones pueden depender del estado del arreglo u objeto\nasumiendo que su estado es el original (antes de llamar a nuestra funci&#xF3;n\n<code>concat</code>), y ahora que hemos mutado ese estado compartido, tenemos que\npreocuparnos por el impacto que tendr&#xE1; dicho cambio en la l&#xF3;gica del programa si\ncambiamos el orden en que se han llamado las funciones. Refactorizar el c&#xF3;digo\npodr&#xED;a resultar en errores apareciendo aqu&#xED; y all&#xE1;, lo que podr&#xED;a arruinar la\nl&#xF3;gica general de nuestra aplicaci&#xF3;n, y como resultado muchos clientes\ndisgustados.</p>\n<p>Veamos ahora c&#xF3;mo podemos corregir esta situaci&#xF3;n:</p>\n<p><strong>concat.js.</strong></p>\n<pre><code class=\"lang-js\">const concat = (left, right) =&gt; {\n  const result = Object.assign([], left)\n\n  right.map(item =&gt; {\n    result.push(item)\n  })\n\n  return result\n}\n\nmodule.exports = concat\n</code></pre>\n<p>Ahora al ejecutar las pruebas obtenemos lo siguiente:</p>\n<pre><code class=\"lang-sh\">$ yarn run jest -- concat.test.js\n PASS  ./concat.test.js\n  &#x2713; should concatenate the array on the right with the array on the left (5ms)\n  &#x2713; should not mutate external context (1ms)\n\nTest Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        0.977s\nRan all test suites matching &quot;concat.test.js&quot;.\n</code></pre>\n<p>&#xBF;Recuerdas que antes hab&#xED;amos mencionado que pod&#xED;amos haber usado\n<code>Array.prototype.concat</code> directamente?, pues veamos una simplificaci&#xF3;n del\nc&#xF3;digo:</p>\n<p><strong>concat.js.</strong></p>\n<pre><code class=\"lang-js\">const concat = (left, right) =&gt; {\n  return left.concat(right)\n}\n\nmodule.exports = concat\n</code></pre>\n<p>Si ejecutas de nuevo las pruebas unitarias ver&#xE1;s que cumplimos con todas las\ncondiciones.</p>\n<hr>\n<p>NOTA: Es com&#xFA;n usar m&#xE9;todos como <code>Array#slice</code>, <code>Array#map</code> o <code>Array#filter</code>\nadem&#xE1;s de <code>Array#concat</code> para crear copias de arreglos. En <strong>ES6</strong> tambi&#xE9;n\ntenemos el <em>spread operator</em> que nos permite copiar las propiedades enumerables\nde un arreglo u objeto de esta forma:</p>\n<pre><code class=\"lang-js\">const array = [1, 2, 3];\nconst arrayCopy = [...a]; // `b` es un nuevo arreglo con los elementos de `a`.\n\nconst obj = { foo: &apos;bar&apos; };\nconst objCopy = {...obj};\n</code></pre>\n<hr>\n<h2 id=\"beneficios\">Beneficios</h2>\n<p>Una vez analizadas las funciones puras, volvamos a repasar los beneficios que\nofrecen, tal como vimos en la apertura de esta unidad:</p>\n<ul>\n<li>Toman ciertos argumentos como entrada y generan un valor de retorno que\nexclusivamente depende de los argumentos dados.</li>\n<li>Representan bloques de c&#xF3;digo reusable dentro de un programa.</li>\n<li>Promueven buenas pr&#xE1;cticas de desarrollo como <a href=\"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\" target=\"_blank\">DRY</a>\n(<em>Don&#x2019;t Repeat Yourself</em>) y <a href=\"https://en.wikipedia.org/wiki/KISS_principle\" target=\"_blank\">KISS</a> (<em>Keep It Simple, Stupid</em>).</li>\n<li>Al no depender del contexto externo, son inmunes a toda clase de errores o\n<em>bugs</em> que tienen que ver con el estado mutable compartido.</li>\n<li>Su naturaleza independiente las hace excelentes candidatos para procesamiento\nconcurrente a lo largo de muchos CPUs e incluso para la computaci&#xF3;n\ndistribuida, lo cual las hace esenciales para la ejecuci&#xF3;n de tareas de\nc&#xE1;lculo cient&#xED;fico y de uso intensivo de recursos.</li>\n<li>Su aislamiento facilita la refactorizaci&#xF3;n y reorganizaci&#xF3;n del c&#xF3;digo,\nhaciendo t&#xFA; c&#xF3;digo m&#xE1;s adaptable y flexible a futuros cambios.</li>\n<li>Es mucho m&#xE1;s sencillo el desarrollo de pruebas unitarias contra funciones\npuras.</li>\n<li>Las funciones puras representan la base de la programaci&#xF3;n funcional.</li>\n</ul>\n<p>Por las razones antes mencionadas, recomendamos favorecer la implementaci&#xF3;n de\nfunciones puras. Por lo tanto, siempre que sea pr&#xE1;ctico implementar los\nrequerimientos de un programa usando funciones puras, debes darle preferencia\nsobre otras opciones.</p>\n<h2 id=\"referencias\">Referencias</h2>\n<ul>\n<li>Conrad Barski. 2010. Land of Lisp: Learn to Program in Lisp, One Game at a\nTime! (1st ed.). No Starch Press, San Francisco, CA, USA. Page 301.</li>\n<li><a href=\"https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976\" target=\"_blank\">Master the JavaScript Interview: What is a Pure Function?</a>. En Medium.\nConsultado el 11 de Julio de 2017</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Side_effect_(computer_science\" target=\"_blank\">Side effect (computer science)</a>)</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Imperative_programming\" target=\"_blank\">Imperative Programming</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase\" target=\"_blank\">String.prototype.toLowerCase()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random\" target=\"_blank\">Math.random()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleDateString\" target=\"_blank\">Date.prototype.toLocaleDateString()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\" target=\"_blank\">Array.prototype.concat()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\">Object.assign()</a></li>\n</ul>\n<h2 id=\"notas-al-pie\">Notas al pie</h2>\n<ol>\n<li>Algunas veces necesitamos aplanar &#xE1;rboles u objetos muy anidados que son\nresultado de una consulta o <em>query</em>, un patr&#xF3;n com&#xFA;n es convertirlos en\narreglos o <em>arrays</em> para luego poder aplicar operaciones como <code>filter()</code> o\n<code>map()</code> sobre ellos.</li>\n</ol>\n"
          },
          "02-practice": {
            "title": "Ejercicios de funciones puras",
            "type": "practice",
            "format": "self-paced",
            "duration": 10,
            "exercises": {
              "01-discount": {
                "title": "Aplicando descuentos",
                "env": "js",
                "body": "<p>Un d&#xED;a aparece un bug en una tienda online en la que est&#xE1;s trabjando. Alguien\ndel equipo ha a&#xF1;adido una nueva funcionalidad para poder aplicar descuentos a\nclientes frecuentes. Para ello, se ha implementado una funci&#xF3;n\n(<code>applyDiscount(cart, discount)</code>) que recibe un arreglo de objetos (el <code>cart</code>),\ncada uno con un precio, y un porcentaje de descuento. La funci&#xF3;n retorna un\narreglo de objetos con los precios modificados de acuerdo al descuento.</p>\n<p>Por ejemplo:</p>\n<pre><code class=\"lang-js\">const myCart = [\n  { price: 1 },\n  { price: 2 },\n  { price: 3 }\n];\n\nconst cartWithDiscount = applyDiscount(myCart, .3);\nconsole.log(myCart, cartWithDiscount);\n</code></pre>\n<p>Ahora, despu&#xE9;s de investigar un rato descubrimos dos problemas:</p>\n<ol>\n<li>La funci&#xF3;n parece estar mutando los objetos dentro del arreglo en vez de\ncrear objetos nuevos!</li>\n<li>La funci&#xF3;n parece estar ignorando el descuento que le indicamos en el\nargumento <code>discount</code> y siempre aplica un 20%!</li>\n</ol>\n<p>El c&#xF3;digo en cuesti&#xF3;n es este:</p>\n<pre><code class=\"lang-js\">const discount = .2;\n\n// Broken: returns new array but mutates objects.\nconst applyDiscount = (cart) =&gt; {\n  if (!cart.length) {\n    return [];\n  }\n\n  const current = cart.shift();\n  current.price *= (1 - discount);\n  return [current].concat(applyDiscount(cart));\n};\n\nmodule.exports = applyDiscount;\n</code></pre>\n<p>En resumen, tal y como est&#xE1; ahora, la funci&#xF3;n no es <em>pura</em> ya que tiene efectos\ncolaterales (modifica el arreglo <code>cart</code>) y hace uso de una variable fuera de su\nscope (<code>discount</code>) en vez de un <em>argumento</em>.</p>\n<h2 id=\"tarea\">Tarea</h2>\n<p>Refactoriza la funci&#xF3;n <code>applyDiscount()</code> para convertirla en una funci&#xF3;n pura.\nPara ello tendr&#xE1;s que:</p>\n<ul>\n<li>Evitar mutar los objetos del arreglo que recibe como argumento.</li>\n<li>Usar el argumento <code>discount</code> que recibe la funci&#xF3;n durante la invocaci&#xF3;n en\nvez de la variable <code>discount</code> declarada fuera de la funci&#xF3;n.</li>\n</ul>\n",
                "files": {
                  "Ym9pbGVycGxhdGU=": {
                    "ZGlzY291bnQuanM=": "'use strict';\n\n\nconst discount = .2;\n\n// Broken: returns new array but mutates same object references.\nconst applyDiscount = (cart) => {\n  if (!cart.length) {\n    return [];\n  }\n\n  const current = cart.shift();\n  current.price *= (1 - discount);\n  return [current].concat(applyDiscount(cart));\n};\n\nmodule.exports = applyDiscount;\n"
                  },
                  "c29sdXRpb24=": {
                    "ZGlzY291bnQuanM=": "'use strict';\n\n\n// Broken: returns new array but mutates same object references.\n// const applyDiscount = (cart) => {\n//   if (!cart.length) {\n//     return [];\n//   }\n//\n//   const current = cart.shift();\n//   current.price *= (1 - discount);\n//   return [current].concat(applyDiscount(cart));\n// };\n\n// Broken: mutates array and objects\n// const applyDiscount = (cart) => {\n//   for (let i = 0; i < cart.length; i++) {\n//     cart[i] *= (1 - discount);\n//   }\n//   return cart;\n// };\n\n// Broken: new array but mutates same object references!!\n// const applyDiscount = (cart, discount) => cart.map(item => {\n//   item.price *= (1 - discount);\n//   return item;\n// });\n\n// Solución 1\nconst applyDiscount = (cart, discount) => {\n  if (!cart.length) {\n    return [];\n  }\n\n  const current = Object.assign({}, cart[0], {\n    price: cart[0].price * (1 - discount)\n  });\n\n  return [current].concat(applyDiscount(cart.slice(1), discount));\n};\n\n// Solución 2\n// const applyDiscount = (cart, discount) =>\n//   (!cart.length && []) || [Object.assign({}, cart[0], {\n//     price: cart[0].price * (1 - discount)\n//   })].concat(applyDiscount(cart.slice(1), discount));\n\n\nmodule.exports = applyDiscount;\n"
                  },
                  "dGVzdA==": {
                    "ZGlzY291bnQuc3BlYy5qcw==": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Submission = require('../solution/discount');\n\n\ndescribe('applyDiscount()', () => {\n\n  it('debería devolver un nuevo array', () => {\n    const cart = [];\n    const result = Submission(cart, .2);\n    Assert.notStrictEqual(cart, result);\n  });\n\n  it('debería devolver un array con mismo length que input', () => {\n    [\n      [],\n      [{ price: 1 }],\n      [{ price: 1 }, { price: 7 }, { price: 19 }]\n    ].forEach(cart => Assert.equal(cart.length, Submission(cart, .2).length));\n  });\n\n  it('no debería mutar array de entrada', () => {\n    const item1 = { price: 1 };\n    const item2 = { price: 2 };\n    const item3 = { price: 3 };\n    const cart = [item1, item2, item3];\n    const cartWithDiscount = Submission(cart, .3);\n    Assert.strictEqual(cart.length, 3);\n    Assert.strictEqual(cart[0], item1);\n    Assert.strictEqual(cart[1], item2);\n    Assert.strictEqual(cart[2], item3);\n    Assert.deepEqual(cart[0], { price: 1 });\n    Assert.deepEqual(cart[1], { price: 2 });\n    Assert.deepEqual(cart[2], { price: 3 });\n  });\n\n  it('no debería mutar objetos', () => {\n    const item1 = { price: 1 };\n    const item2 = { price: 2 };\n    const item3 = { price: 3 };\n    const cart = [item1, item2, item3];\n    const cartWithDiscount = Submission(cart, .3);\n    Assert.strictEqual(cart.length, 3);\n    Assert.strictEqual(cart[0].price, 1);\n    Assert.strictEqual(cart[1].price, 2);\n    Assert.strictEqual(cart[2].price, 3);\n  });\n\n  it('debería retornar objetos con descuento indicado', () => {\n    const item1 = { price: 1 };\n    const item2 = { price: 2 };\n    const item3 = { price: 3 };\n    const cart = [item1, item2, item3];\n    const cartWithDiscount = Submission(cart, .3);\n    Assert.strictEqual(cartWithDiscount[0].price, 1 * (1 - .3));\n    Assert.strictEqual(cartWithDiscount[1].price, 2 * (1 - .3));\n    Assert.strictEqual(cartWithDiscount[2].price, 3 * (1 - .3));\n  });\n\n});\n"
                  }
                }
              },
              "02-serialize-user": {
                "title": "serializeUser()",
                "env": "js",
                "body": "<p>Imag&#xED;nate que est&#xE1;s trabajando en una aplicaci&#xF3;n donde tienes una funci&#xF3;n\nllamada <code>serializeUser()</code> que lo que hace es convertir un objeto de usuario en\nun string en formato JSON. Adem&#xE1;s, hace un par de modificaciones (limita el\nnombre a 10 caracteres y convierte la fecha en un string).</p>\n<p>Veamos un ejemplo:</p>\n<pre><code class=\"lang-js\">const grace = {\n    userId: &apos;xxx&apos;,\n    name: &apos;Grace Hopper&apos;,\n    country: &apos;us&apos;,\n    date: new Date()\n};\n\nserializeUser(grace);\n// =&gt; {&quot;userId&quot;:&quot;xxx&quot;,&quot;name&quot;:&quot;Grace H...&quot;,&quot;country&quot;:&quot;us&quot;,&quot;date&quot;:&quot;2017-09-07T21:42:09.152Z&quot;}\n</code></pre>\n<p>Ahora, el problema es que cuando implementaron la funci&#xF3;n <code>serializeUser()</code>, lo\nhicieron de tal forma que la funci&#xF3;n muta el objeto que le mandamos como\nargumento!</p>\n<p>La implementaci&#xF3;n actual luce as&#xED;:</p>\n<pre><code class=\"lang-js\">const serializeUser = user =&gt; {\n    user.name = (user.name.length &gt; 10) ? `${user.name.slice(0, 7)}...` : user.name;\n    user.date = user.date.toJSON();\n    return JSON.stringify(user);\n};\n\nmodule.exports = serializeUser;\n</code></pre>\n<h2 id=\"tarea\">Tarea</h2>\n<p>Refactoriza la funci&#xF3;n <code>serializeUser()</code> para convertirla en una funci&#xF3;n pura y\nevitar que modifique el objeto que recibe como argumento.</p>\n",
                "files": {
                  "Ym9pbGVycGxhdGU=": {
                    "c2VyaWFsaXplVXNlci5qcw==": "const serializeUser = user => {\n\tuser.name = (user.name.length > 10) ? `${user.name.slice(0, 7)}...` : user.name;\n\tuser.date = user.date.toJSON();\n\treturn JSON.stringify(user);\n};\n\nmodule.exports = serializeUser;\n"
                  },
                  "c29sdXRpb24=": {
                    "c2VyaWFsaXplVXNlci5qcw==": "const serializeUser = user => JSON.stringify(Object.assign({}, user, {\n  name: (user.name.length > 10) ? `${user.name.slice(0, 7)}...` : user.name,\n  date: user.date.toJSON(),\n}));\n\nmodule.exports = serializeUser;\n"
                  },
                  "dGVzdA==": {
                    "c2VyaWFsaXplVXNlci5zcGVjLmpz": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Submission = require('../solution/serializeUser');\n\n\ndescribe('serializeUser()', () => {\n\n  it('debería retornar un string con el objeto serializado como JSON', () => {\n    const grace = {\n    \tuserId: 'xxx',\n    \tname: 'Grace Hopper',\n    \tcountry: 'us',\n    \tdate: new Date()\n    };\n    const dateStr = grace.date.toJSON();\n    Assert.equal(\n      Submission(grace),\n      `{\"userId\":\"xxx\",\"name\":\"Grace H...\",\"country\":\"us\",\"date\":\"${dateStr}\"}`\n    );\n  });\n\n  it('no debería mutar el objeto que recibe como argumento', () => {\n    const grace = {\n      userId: 'xxx',\n      name: 'Grace Hopper',\n      country: 'us',\n      date: new Date()\n    };\n    Assert.equal(grace.name, 'Grace Hopper');\n    Assert.ok(grace.date instanceof Date);\n  });\n\n});\n"
                  }
                }
              }
            }
          },
          "03-immutability": {
            "title": "Inmutabilitidad",
            "type": "lectura",
            "format": "self-paced",
            "duration": 30,
            "body": "<p>La inmutabilidad es un principio fundamental en la programaci&#xF3;n funcional, y\ntambi&#xE9;n tiene ventajas que ofrecer a otros paradigmas como el orientado a\nobjetos. En esta lecci&#xF3;n mostraremos qu&#xE9; es la inmutabilidad, c&#xF3;mo podemos\naprovechar este concepto en JavaScript, y por qu&#xE9; es tan &#xFA;til.</p>\n<h2 id=\"-qu-es-la-inmutabilidad-\">&#xBF;Qu&#xE9; es la inmutabilidad?</h2>\n<p>La definici&#xF3;n de mutabilidad indica que algo est&#xE1; sujeto a cambios o\nmodificaciones. En programaci&#xF3;n, cuando decimos que un objeto es mutable nos\nreferimos a que est&#xE1; permitido modificar el estado de dicho objeto a lo largo\ndel tiempo. Un valor <strong>inmutable</strong> indica exactamente lo opuesto, despu&#xE9;s que\ndicho valor es creado, no puede ser cambiado o alterado nunca.</p>\n<p>Esto parece ser un poco extra&#xF1;o, pero recordemos que muchos valores que usamos\ntodo el tiempo en realidad son inmutables.</p>\n<p>Algunos tipos de datos en JavaScript son inmutables por omisi&#xF3;n. Las cadenas de\ncaracteres o <em>strings</em> son un ejemplo de un tipo de dato que no puede ser\ncambiado.</p>\n<p><strong>strings.test.js.</strong></p>\n<pre><code class=\"lang-js\">test(&apos;should not change the value of the original string&apos;, () =&gt; {\n  const lesson = &apos;immutability&apos;\n\n  expect(lesson.toUpperCase()).toBe(&apos;IMMUTABILITY&apos;)\n  expect(lesson).toBe(&apos;immutability&apos;)\n})\n</code></pre>\n<p>Si ejecutamos las pruebas anteriores veremos que el valor original de la cadena\n(<code>immutability</code>) no es modificado tras la operaci&#xF3;n ejecutada:</p>\n<pre><code class=\"lang-sh\">$ yarn run jest strings.test.js\nPASS  ./strings.test.js\n&#x2713; should not change the value of the original string (5ms)\n\n  Test Suites: 1 passed, 1 total\n  Tests:       1 passed, 1 total\n  Snapshots:   0 total\n  Time:        0.941s, estimated 1s\n  Ran all test suites matching &quot;strings.test.js&quot;.\n  &#x2728;  Done in 1.56s.\n</code></pre>\n<p>De hecho, ning&#xFA;n m&#xE9;todo sobre cadenas de caracteres puede cambiar la cadena\nsobre la que opera, todos ellos retornan nuevas cadenas de caracteres. La raz&#xF3;n\ntras esto radica en que las cadenas de caracteres son inmutables. Por lo tanto,\nsu valor no puede cambiar, nosotros solo podemos crear nuevos <em>strings</em>.</p>\n<p>Las cadenas de caracteres no son los &#xFA;nicos valores inmutables dentro de\nJavaScript. Los n&#xFA;meros tambi&#xE9;n son inmutables. &#xBF;Te puedes imaginar un entorno\nen donde al evaluar la expresi&#xF3;n 2 + 3 cambie autom&#xE1;ticamente el significado del\nn&#xFA;mero 2?, suena absurdo, &#xBF;verdad?. Sin embargo, solemos modificar nuestros\nobjetos y arreglos todo el tiempo!</p>\n<h2 id=\"inmutabilidad-y-su-relaci-n-con-la-recursividad\">Inmutabilidad y su relaci&#xF3;n con la recursividad</h2>\n<p>M&#xE1;s adelante hablaremos con mayor detalle sobre recursividad. Sin embargo, vale\nacotar que es un patr&#xF3;n que se suele ver en la programaci&#xF3;n funcional.</p>\n<p>En algunos lenguajes funcionales no puedes escribir la siguiente funci&#xF3;n\nhaciendo uso de mutaci&#xF3;n local:</p>\n<pre><code class=\"lang-js\">const range = require(&apos;lodash.range&apos;)\n\nconst summ = array =&gt; {\n  let result = 0\n  const size = array.length\n\n  for (let i = 0; i &lt; size; i++) {\n    result += array[i]\n  }\n\n  return result\n}\n\nsumm(range(11))\n// =&gt; 55\n</code></pre>\n<p>El problema es que la funci&#xF3;n anterior modifica el estado de dos variables\nlocales. Sin embargo, en lenguajes funcionales tradicionales, las variables\nlocales no son <em>variables</em> en s&#xED;, son inmutables. En este caso, la &#xFA;nica v&#xED;a\npara modificar el valor de una variable local es por medio del <em>call stack</em>, y\nesto es lo que precisamente logramos con la recursi&#xF3;n. Veamos una\nreimplementaci&#xF3;n de la funci&#xF3;n previa usando recursividad:</p>\n<pre><code class=\"lang-js\">const range = require(&apos;lodash.range&apos;)\nconst isEmpty = require(&apos;lodash.isempty&apos;)\n\nconst summRec = (array, seed = 0) =&gt; {\n  const [head, ...tail] = array\n  return isEmpty(array) ? seed : summRec(tail, head + seed)\n}\n\nsummRec([])\n// =&gt; 0\n\nsummRec(range(11))\n// =&gt; 55\n</code></pre>\n<p>Cuando usamos recursividad, el cambio de estado es modelado por medio de los\nargumentos pasados en la funci&#xF3;n recursiva. JavaScript permite el manejo del\nestado de manera recursiva, pero tiene ciertos l&#xED;mites que veremos m&#xE1;s adelante.\nLo importante es hacer notar que existe cierta relaci&#xF3;n entre la recursividad y\nla inmutabilidad de las variables locales.</p>\n<h2 id=\"en-javascript-los-tipos-de-datos-mutables-abundan\">En JavaScript, los tipos de datos mutables abundan</h2>\n<p>Ya esto lo hemos mencionado, pero vale la pena ahondar en ello:</p>\n<pre><code class=\"lang-js\">let initial = [&apos;hello&apos;]\nlet greeting = initial.push(&apos;world&apos;)\n</code></pre>\n<p>Podr&#xED;amos asumir que el resultado ser&#xED;a el siguiente:</p>\n<pre><code class=\"lang-js\">initial = [&apos;hello&apos;]\ngreeting = [&apos;hello&apos;, &apos;world&apos;]\n</code></pre>\n<p>Parece l&#xF3;gico, &#xBF;no?, pues resulta que en realidad el resultado es el siguiente:</p>\n<pre><code class=\"lang-js\">initial = [&apos;hello&apos;, &apos;world&apos;]\ngreeting = 2\n</code></pre>\n<p>El m&#xE9;todo <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push\" target=\"_blank\">Array.prototype.push()</a> agrega uno o m&#xE1;s elementos al final del\narray <em>in situ</em> y retorna la <em>longitud</em> del array. Es decir, a diferencia de los\nm&#xE9;todos sobre las cadenas de caracteres, en este caso observamos que se esta\nmutando la variable (<code>arr</code>) original.</p>\n<p>Ahora imagina por un momento que tenemos un tipo de dato denominado\n<code>ImmutableArray</code> y tiene un comportamiento similar a las cadenas de caracteres\ny n&#xFA;meros:</p>\n<pre><code class=\"lang-js\">const initial = new ImmutableArray([&apos;hello&apos;])\nconst greeting = initial.push(&apos;world&apos;)\n\ninitial.toArray() // =&gt; [&apos;hello&apos;]\ngreeting.toArray() // =&gt; [&apos;hello&apos;, &apos;world&apos;]\n</code></pre>\n<p>Tambi&#xE9;n imagina que tenemos un tipo de dato mapa inmutable, en donde el\nestablecimiento de nuevas propiedades sobre el objeto o mapa en realidad no\nestablece el valor <em>in situ</em>, en vez de ello devuelve un nuevo objeto con los\ncambios deseados:</p>\n<pre><code class=\"lang-js\">const firstOrder = new ImmutableMap({name: &apos;Julia&apos;, details: &apos;espresso macchiato&apos;})\nconst newOrder = firstOrder.set(&apos;details&apos;: &apos;doppio&apos;)\n\nfirstOrder.toObject() // =&gt; {name: &apos;Julia&apos;, details: &apos;espresso macchiato&apos;}\nnewOrder.toObject() // =&gt; {name: &apos;Julia&apos;, details: &apos;doppio&apos;}\n</code></pre>\n<p>Al igual que las operaciones con cadenas de caracteres, el cambio de la orden\nde Julia, no implica que originalmente no haya solicitado un <em>espresso\nmacchiato</em>.</p>\n<p>Si quisieramos incluir este tipo de estructuras de datos en nuestras\naplicaciones al menos por ahora debemos recurrir a bibliotecas externas, por\nejemplo, haciendo uso de <a href=\"http://facebook.github.io/immutable-js/\" target=\"_blank\">immutable.js</a> tendr&#xED;amos lo siguiente:</p>\n<pre><code class=\"lang-js\">const Map = require(&apos;immutable&apos;)\nconst firstOrder = Map({name: &apos;Julia&apos;, details: &apos;espresso macchiato&apos;})\nconst newOrder = firstOrder.set(&apos;details&apos;: &apos;doppio&apos;)\n\nfirstOrder.get(&apos;details&apos;) // =&gt; &apos;espresso macchiato&apos;\nnewOrder.get(&apos;details&apos;) // =&gt; &apos;doppio&apos;\n</code></pre>\n<hr>\n<h2 id=\"lecturas-complementarias\">Lecturas complementarias</h2>\n<h3 id=\"object-freeze-y-clone\">Object.freeze() y clone</h3>\n<p>Dado que JavaScript pasa <em>arrays</em> y objetos por referencia, nada en realidad es\ninmutable en estos casos. Tambi&#xE9;n, dado que los campos o propiedades de los\nobjetos en JavaScrit son siempre visibles, no hay una manera sencilla de\nhacerlos inmutables. Existen maneras de ocultar datos usando encapsulaci&#xF3;n para\nevitar cambios accidentales, pero en l&#xED;neas generales, todos los objetos en\nJavaScrit son mutables, a menos que sean congelados.</p>\n<p>Versiones recientes de JavaScript proveen el m&#xE9;todo <code>Object#freeze</code>, que dado un\nobjeto o <em>array</em>, causar&#xE1; que las siguientes mutaciones fallen. En el caso de\nestar usando el modo estricto, la falla generar&#xE1; una excepci&#xF3;n <code>TypeError</code>, de\nlo contrario, cualquier mutaci&#xF3;n fallar&#xE1; silenciosamente.</p>\n<p>El m&#xE9;todo <code>freeze</code> funciona como sigue a continuaci&#xF3;n:</p>\n<pre><code class=\"lang-js\">let a = [1, 2, 3]\na[1] = 42\na // =&gt; [1, 42, 3]\n\nObject.freeze(a)\n</code></pre>\n<p>Un <em>array</em> normal es mutable por omisi&#xF3;n, pero despu&#xE9;s de llamar a\n<code>Object#freeze</code>, lo que ocurre es lo siguiente:</p>\n<pre><code class=\"lang-js\">a[1] = 108\na // =&gt; [1, 42, 3]\n</code></pre>\n<p>Esto es, la mutaci&#xF3;n que se intent&#xF3; hacer sobre el <em>array</em> no tuvo efecto.\nTambi&#xE9;n podemos hacer uso del m&#xE9;todo <code>Object#isFrozen</code> para verificar si el\n<em>array</em> est&#xE1; congelado:</p>\n<pre><code class=\"lang-js\">Object.isFrozen(a)\n// =&gt; true\n</code></pre>\n<p>Existen dos problemas al usar <code>Object#freeze</code> para asegurar inmutabilidad.</p>\n<ul>\n<li>A menos que tengas completo control de la base de c&#xF3;digo del proyecto, algunos\nerrores podr&#xED;an ocurrir.</li>\n<li>El m&#xE9;todo <code>Object#freeze</code> es <em>shallow</em>.</li>\n</ul>\n<p>En el primer punto podr&#xED;amos argumentar que otras compa&#xF1;eras de trabajo podr&#xED;an\nasumir por ejemplo que el objeto o <em>array</em> es mutable, cuando no es as&#xED;. Tambi&#xE9;n\npodr&#xED;amos considerar que una biblioteca que uses explota la mutabilidad de los\nobjetos o <em>arrays</em>. Por lo tanto, congelar objetos y pasarlos a otras APIs\narbitrarias podr&#xED;a ser causa de problemas.</p>\n<p>Ahora bien, el otro argumento en contra de <code>Object#freeze</code> es que es una\noperaci&#xF3;n <em>shallow</em>. Esto es, <code>freeze</code> solo aplicar&#xE1; en el nivel superior de la\nestructura de datos y no recorrer&#xE1; niveles anidados. Por ejemplo:</p>\n<pre><code class=\"lang-js\">let x = [{a: [1, 2, 3], b: 42}, {c: {d: []}}]\n\nObject.freeze(x)\n\nx[0] = &apos;&apos;\nx\n// =&gt; [{a: [1, 2, 3], b: 42}, {c: {d: []}}]\n</code></pre>\n<p>El intento de modificaci&#xF3;n del <em>array</em> falla. Sin embargo, realizar una mutaci&#xF3;n\nde una porci&#xF3;n anidada dentro de dicho arreglo es posible:</p>\n<pre><code class=\"lang-js\">x[1][&apos;c&apos;][&apos;d&apos;] = 100000\nx\n// =&gt; [ { a: [ 1, 2, 3 ], b: 42 }, { c: { d: 100000 } } ]\n</code></pre>\n<p>Para aplicar un congelamiento profundo sobre un objecto, tendremos que usar\nrecursi&#xF3;n para recorrer la estructura de datos:</p>\n<pre><code class=\"lang-js\">const _ = require(&apos;lodash&apos;)\n\nconst deepFreeze = obj =&gt; {\n  if (!Object.isFrozen(obj)) {\n    Object.freeze(obj)\n  }\n\n  for (const key in obj) {\n    if (!obj.hasOwnProperty(key) || !_.isObject(obj[key])) {\n      continue\n    }\n    deepFreeze(obj[key])\n  }\n}\n</code></pre>\n<p>Ahora, podemos usar <code>deepFreeze</code> y esperar el comportamiento adecuado:</p>\n<pre><code class=\"lang-js\">const x = [{a: [1, 2, 3], b: 42}, {c: {d: []}}]\ndeepFreeze(x)\nx[0] = null\nx\n// =&gt; [ { a: [ 1, 2, 3 ], b: 42 }, { c: { d: [] } } ]\nx[1][&apos;c&apos;][&apos;d&apos;] = 100000\nx\n// =&gt; [ { a: [ 1, 2, 3 ], b: 42 }, { c: { d: [] } } ]\n</code></pre>\n<p>Sin embargo, es necesario considerar de nuevo que el congelamiento de objetos\npuede generar errores al interactuar con APIs terceras. Por lo que nuestras\nopciones se ven reducidas a las siguientes:</p>\n<ul>\n<li>Usar <code>_.clone</code> si conoces de antemano que un <em>shallow</em> copy es apropiado</li>\n<li>Crear <code>deepClone</code> (similar a la funci&#xF3;n <code>deepFreeze</code>) para hacer copias de\nestructuras de datos anidadas</li>\n<li>Construir t&#xFA; c&#xF3;digo basado en funciones puras</li>\n<li>Usar bibliotecas externas que te permitan manejar estructuras de datos\ninmutables</li>\n</ul>\n<h3 id=\"acerca-del-rendimiento\">Acerca del rendimiento</h3>\n<p>Puedes pensar que al usar estructuras de datos inmutables est&#xE1;s afectando\nsobremanera el rendimiento de t&#xFA; aplicaci&#xF3;n y puede que tengas raz&#xF3;n. Siempre\nque se ejecute alguna operaci&#xF3;n que modifica al objeto inmutable, se\nnecesitar&#xE1; crear una nueva instancia copiando los valores existentes y\nagregando las nuevas propiedades necesarias. Esto ciertamente pueden ser\noperaciones costosas a nivel computacional que simplemente mutar un simple\nobjeto.</p>\n<p>Sin embargo, al saber que un objeto inmutable nunca cambiar&#xE1;, dichas\nestructuras pueden ser implementadas usando una estrateg&#xED;a denominada\n<em>structural sharing</em>, lo cual resulta ser menos costoso en el uso de la memoria\nde lo que imaginas.  Por supuesto, no ser&#xE1; tan r&#xE1;pido si lo comparamos con los\n<em>arrays</em> y <em>objetos</em> nativos, pero los beneficios que brindan las estructuras\nde datos inmutables pueden ser mayores. En la practica, es posible que el uso de\nestructuras de datos inmutables mejore el rendimiento global de t&#xFA; aplicaci&#xF3;n,\nsin importar que ciertas operaciones particulares sean m&#xE1;s costosas por el tipo\nde operaciones que realizan.</p>\n<h3 id=\"seguimiento-de-cambios\">Seguimiento de cambios</h3>\n<p>Las operaciones a nivel de DOM, o determinar qu&#xE9; componentes de la vista deben\nser actualizados dado ciertos cambios en el modelo, suelen ser costosas por lo\nque minimizar el n&#xFA;mero de operaciones necesarias para la actualizar la UI\nsiempre es bienvenido.</p>\n<p>Una manera eficiente de reducir el n&#xFA;mero de operaciones necesarias para\nactualizar la UI es utilizar estructuras de datos que cumplan con las siguientes\ncondiciones:</p>\n<ul>\n<li>Inmutables: Una vez creadas, una colecci&#xF3;n no puede ser alterada en ning&#xFA;n\notro momento.</li>\n<li>Persistente: Nuevas colecciones pueden ser creadas a partir de previas, (ej.\npor medio de operaciones como <code>set</code>). La colecci&#xF3;n original seguir&#xE1; siendo\nv&#xE1;lida incluso despu&#xE9;s de la creaci&#xF3;n de la nueva colecci&#xF3;n.</li>\n<li><em>structural sharing</em>: Nuevas colecciones son creadas usando tanto como sea\nposible la misma estructura de la colecci&#xF3;n original, reduciendo la copia al\nm&#xED;nimo para mejorar el rendimiento.</li>\n</ul>\n<p>La inmutabilidad hace que el seguimiento de cambios sea barato. Un cambio\nsiempre resultar&#xE1; en un nuevo objeto, por lo que solo es necesario verificar si\nla referencia al objeto ha cambiado. Por ejemplo, en este ejemplo de c&#xF3;digo\nregular JavaScript:</p>\n<pre><code class=\"lang-js\">const x = { foo: &apos;bar&apos; };\nconst y = x;\ny.foo = &apos;baz&apos;;\nx === y; // =&gt; true\n</code></pre>\n<p>Sin embargo, <code>y</code> fue editada, dado que es una referencia al mismo objeto <code>x</code>,\nesta comparaci&#xF3;n retorna <code>true</code>. Podemos escribir c&#xF3;digo similar con\nimmutable.js:</p>\n<pre><code class=\"lang-js\">const SomeRecord = Immutable.Record({ foo: null });\nconst x = new SomeRecord({ foo: &apos;bar&apos; });\nconst y = x.set(&apos;foo&apos;, &apos;baz&apos;);\nconst z = x.set(&apos;foo&apos;, &apos;bar&apos;);\nx === y; // =&gt; false\nx === z; // =&gt; true\n</code></pre>\n<p>En este caso, dado que una referencia se retorna al realizar una mutaci&#xF3;n sobre\n<code>x</code>, podemos utilizar el chequeo de igualdad (<code>x === y</code>) para verificar que un\nnuevo valor se ha almacenado en <code>y</code> y es diferente al original almacenado en\n<code>x</code>. Esto puede implicar un incremento significativo en el rendimiento.</p>\n<h2 id=\"referencias\">Referencias</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\" target=\"_blank\">Object.freeze()</a></li>\n<li><a href=\"https://www.sitepoint.com/immutability-javascript/\" target=\"_blank\">Immutability in JavaScript</a></li>\n<li><a href=\"http://shop.oreilly.com/product/0636920028857.do\" target=\"_blank\">Functional JavaScript</a> de\nMichael Fogus</li>\n<li><a href=\"https://facebook.github.io/react/docs/optimizing-performance.html\" target=\"_blank\">React: Optimizing Performance</a></li>\n</ul>\n"
          },
          "04-practice": {
            "title": "Ejercicios de inmutabilidad",
            "type": "practice",
            "format": "self-paced",
            "duration": 10,
            "exercises": {
              "01-parse-items": {
                "title": "Parse items",
                "body": "<p>Refactoriza le siguiente funci&#xF3;n para que devuelva un nuevo arreglo en vez de\nmodificar el arreglo que recibe como argumento.</p>\n<pre><code class=\"lang-js\">const parseItems = items =&gt; {\n  for (let i = 0; i &lt; items.length; i++) {\n    items[i] = parseInt(items[i]);\n  }\n  return items.sort();\n};\n</code></pre>\n<h2 id=\"pistas\">Pistas</h2>\n<ul>\n<li>Puedes usar <code>Array#map()</code> para iterar sobre el array y aplicar la\ntransformaci&#xF3;n requerida (<code>parseInt()</code>).</li>\n</ul>\n",
                "files": {
                  "Ym9pbGVycGxhdGU=": {
                    "cGFyc2VJdGVtcy5qcw==": "const parseItems = (items) => {\n  for (let i = 0; i < items.length; i++) {\n    items[i] = parseInt(items[i]);\n  }\n  return items.sort();\n};\n\nmodule.exports = parseItems;\n"
                  },
                  "c29sdXRpb24=": {
                    "cGFyc2VJdGVtcy5qcw==": "const parseItems = items => items.map(item => parseInt(item)).sort();\n\nmodule.exports = parseItems;\n"
                  },
                  "dGVzdA==": {
                    "cGFyc2VJdGVtcy5zcGVjLmpz": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Submission = require('../solution/parseItems');\n\n\ndescribe('parseItems()', () => {\n\n  it('debería retornar un nuevo arreglo', () => {\n    const original = ['6', '3', '5', '2', '4'];\n    const parsed = Submission(original);\n\n    Assert.notDeepEqual(original, parsed);\n    Assert.notEqual(original, parsed);\n  });\n\n  it('debería retornar un arreglo de números', () => {\n    Submission(['6', '3', '5', '2', '4']).forEach(Assert.isNumber);\n  });\n\n  it('debería retornar un arreglo ordenado', () => {\n    Assert.deepEqual(Submission(['6', '3', '5', '2', '4']), [2, 3, 4, 5, 6]);\n  });\n\n  it('no debería mutar arreglo de entrada', () => {\n    const original = ['6', '3', '5', '2', '4'];\n    const parsed = Submission(original);\n    Assert.deepEqual(original, ['6', '3', '5', '2', '4']);\n  });\n\n});\n"
                  }
                }
              }
            }
          },
          "05-quiz": {
            "title": "Cuestionario",
            "type": "quiz",
            "format": "self-paced",
            "duration": 10,
            "questions": [
              {
                "title": "Una función pura es...",
                "description": "",
                "answers": [
                  "una funci&#xF3;n flecha (arrow function)",
                  "una funci&#xF3;n sin argumentos de entrada ni valor de retorno",
                  "una funci&#xF3;n que dados los mismos inputs siempre retorna lo mismo, y sin\nefectos secundarios",
                  "una funci&#xF3;n que no hace uso de <code>this</code>"
                ],
                "solution": [
                  2
                ]
              },
              {
                "title": "Dada la siguiente función processData(), dirías que es pura?",
                "description": "<pre><code class=\"lang-js\">const data = [&apos;beep&apos;, &apos;boop&apos;];\n\nconst processData = () =&gt; {\n  const result = [];\n  for (let i = 0; i &lt; data.length; i++) {\n    result.push(data[i].toLowerCase());\n  }\n  return result;\n};\n</code></pre>",
                "answers": [
                  "S&#xED;",
                  "No"
                ],
                "solution": [
                  1
                ]
              },
              {
                "title": "Efectos secundarios",
                "description": "<p>Se dice que una funci&#xF3;n tiene efectos secundarios cuando:</p>",
                "answers": [
                  "Invoca a otras funciones durante su ejecuci&#xF3;n",
                  "Cambia estado fuera de su scope",
                  "Programa tareas para que se ejecuten en el futuro",
                  "Retorna funciones"
                ],
                "solution": [
                  1
                ]
              }
            ]
          },
          "06-seminar": {
            "title": "Solucionarios y ejercicios guiados",
            "type": "seminario",
            "format": "guiado",
            "duration": 45,
            "body": "<p>En este seminario revisaremos los ejercicios vistos en esta unidad, lxs\ninstructorxs har&#xE1;n ejercicios guiados y respond&#xE1;n sus preguntas.</p>\n<h2 id=\"requisitos\">Requisitos</h2>\n<ul>\n<li>Haber completado ejercicios de funciones puras e immutabilidad</li>\n</ul>\n"
          },
          "07-quiz": {
            "title": "Cuestionario",
            "type": "quiz",
            "format": "self-paced",
            "duration": 10,
            "questions": [
              {
                "title": "Cuáles de las siguientes son características de las funciones puras?",
                "description": "",
                "answers": [
                  "No tienen efectos secundarios",
                  "No usan argumentos de entrada",
                  "Siempre devuelven lo mismo dados los mismos argumentos",
                  "Hacen uso de variables fuera de su scope"
                ],
                "solution": [
                  0,
                  2
                ]
              },
              {
                "title": "Dado el siguiente snippet, cuáles serán los valores de a y b?",
                "description": "<pre><code class=\"lang-js\">const foo = str =&gt; {\n  str = `===${str}===`;\n  return str;\n};\n\nconst a = &apos;hola&apos;;\nconst b = foo(a);\n</code></pre>",
                "answers": [
                  "&quot;a&quot; ser&#xE1; &apos;hola&apos; y &quot;b&quot; ser&#xE1; &apos;===hola===&apos;",
                  "&quot;a&quot; ser&#xE1; &apos;===hola===&apos; y &quot;b&quot; ser&#xE1; &apos;===hola===&apos;"
                ],
                "solution": [
                  0
                ]
              },
              {
                "title": "La siguiente función modifica...",
                "description": "<pre><code class=\"lang-js\">const foo = arr =&gt; arr.sort();\nconst a = [4, 1, 3, 2];\nconst b = foo(a);\nconst c = (a == b);\n</code></pre>",
                "answers": [
                  "&quot;a&quot; ser&#xE1; [4, 1, 3, 2], &quot;b&quot; ser&#xE1; [1, 2, 3, 4] y &quot;c&quot; ser&#xE1; true",
                  "&quot;a&quot; ser&#xE1; [1, 2, 3, 4], &quot;b&quot; ser&#xE1; [1, 2, 3, 4] y &quot;c&quot; ser&#xE1; false",
                  "&quot;a&quot; ser&#xE1; [4, 1, 3, 2], &quot;b&quot; ser&#xE1; [1, 2, 3, 4] y &quot;c&quot; ser&#xE1; false",
                  "&quot;a&quot; ser&#xE1; [1, 2, 3, 4], &quot;b&quot; ser&#xE1; [1, 2, 3, 4] y &quot;c&quot; ser&#xE1; true"
                ],
                "solution": [
                  3
                ]
              }
            ]
          },
          "08-closing": {
            "title": "Cierre",
            "type": "seminario",
            "format": "guiado",
            "duration": 15,
            "body": "<h3 id=\"resumen\">Resumen</h3>\n<p>Llegamos al final de la unidad ;-)</p>\n<p>En la programaci&#xF3;n funcional, las programadoras tienden a evitar dos h&#xE1;bitos\ncomunes en otros lenguajes:</p>\n<ul>\n<li><em>Mutaci&#xF3;n:</em> Cambio de los datos <em>in-situ</em> en vez de retornar un valor.</li>\n<li><em>Estado compartido:</em> Contexto extra que no se provee como argumento a la\nfunci&#xF3;n, por ejemplo, variables globales.</li>\n</ul>\n<p>Al no depender del estado ni de las mutaciones, el comportamiento de cada\nfunci&#xF3;n est&#xE1; contenido. Por lo tanto, es m&#xE1;s sencillo realizar pruebas del\ncomportamiento de dichas funciones, entre otra serie de beneficios.</p>\n<p>Una vez dicho todo esto, existen ocasiones donde el uso de funciones puras no es\nposible, especialmente en funciones que emplean <em>side-effects</em> para llevar a\ncabo su cometido, por ejemplo el uso de promesas en JavaScript. Pero este tema,\nlo veremos en una siguiente lecci&#xF3;n.</p>\n<h3 id=\"respondamos-juntxs-las-preguntas-de-la-apertura\">Respondamos juntxs las preguntas de la apertura</h3>\n<ul>\n<li>C&#xF3;mo evitar que nuestras funciones tengan efectos colaterales?</li>\n<li>Por qu&#xE9; es beneficioso evitar el estado compartido?</li>\n<li>Cu&#xE1;les son las ventajas que ofrecen las funciones puras, en particular a la\nhora de hacer testing?</li>\n<li>C&#xF3;mo evitar la mutaci&#xF3;n de objetos y arreglos?</li>\n<li>Qu&#xE9; tipos de datos son mutables e inmutables en JavaScript?</li>\n<li>C&#xF3;mo usar m&#xE9;todos de arreglos como <code>Array#concat</code>, <code>Array#slice</code>, <code>Array#map</code>,\n<code>Array#filter</code>, ... para crear arreglos nuevos en vez de mutar (modificar)\nvalores existentes?</li>\n<li>C&#xF3;mo usar m&#xE9;todos de objetos (por ejemplo <code>Object.assign()</code>) para copiar\npropiedades y as&#xED; <em>clonar</em> objetos?</li>\n<li>C&#xF3;mo usar el <em>spread operator</em> (<code>...</code>) para copiar objetos y arreglos?</li>\n</ul>\n<h3 id=\"auto-evaluaci-n\">Auto-evaluaci&#xF3;n</h3>\n<p>Tus instructorxs te compartir&#xE1;n un link al cuestionario de <em>auto evaliaci&#xF3;n</em>.\nEste cuestionario no es calificado.</p>\n"
          }
        }
      },
      "02-workshop": {
        "title": "Hacking: refactoring",
        "bonus": false,
        "description": "<p>Esta unidad es básicamente una sesión de programación por pares. La tarea a\nrealizar será refactorizar varias funciones de un videojuego existente haciendo\nuso de <strong>funciones puras</strong> y <strong>estructuras inmutables</strong>. La duración estimada de\nesta unidad es de <em>2h</em>.</p>\n",
        "parts": {
          "00-opening": {
            "title": "Apertura",
            "type": "seminario",
            "format": "guiado",
            "duration": 15,
            "body": "<p>Esta unidad se compone de un taller de <em>implementaci&#xF3;n por pares</em> en el que\nvamos a refactorizar una parte de un videojuego basado en c&#xF3;digo existente.</p>\n<p>Durante el kick-off del curso tus instructorxs te dar&#xE1;n acceso un repositorio\nen GitHub con el c&#xF3;digo fuente necesario para los talleres de este curso.</p>\n<h2 id=\"requisitos\">Requisitos</h2>\n<ul>\n<li>Es fundamental tener instalado y configurado <code>git</code>, <code>node</code> y <code>npm</code></li>\n<li>Cuenta en <a href=\"https://github.com/\" target=\"_blank\">GitHub</a></li>\n<li>Acceso al repo de tu cohort</li>\n</ul>\n<p>Para comenzar, aseg&#xFA;rate de que tienes tu propio <em>fork</em> del repo de tu cohort y\nuna copia local del repo para trabajar. Si necesitas ayuda con esto tus\ninstructorxs te pueden echar una mano.</p>\n<p>Crea un nuevo branch para este workshop:</p>\n<pre><code class=\"lang-sh\">git checkout -b &lt;tu-usuario-de-github&gt;\n</code></pre>\n<p>Dentro del repo hay un <code>README.md</code> con las instrucciones espec&#xED;ficas.</p>\n<p>Al final del workshop tendr&#xE1;s que hacer commit de tus cambios, push a tu fork y\nfinalmente un PR a tu rama en el repo alojado en la cuenta de Laboratoria.</p>\n"
          },
          "01-refactoring": {
            "title": "Implementación por pares",
            "type": "taller",
            "format": "self-paced",
            "duration": 90,
            "body": "<p>En este workshop refactorizar&#xE1;s un <em>m&#xF3;dulo</em> llamado <code>Loader</code> de un video juego\nya existente (el que usamos en el curso anterior). Este m&#xF3;dulo se encarga de\npre-cargar im&#xE1;genes del juego y tiene dos m&#xE9;todos:</p>\n<ul>\n<li><code>loadImage(key, src)</code></li>\n<li><code>getImage(key)</code></li>\n</ul>\n<p>El c&#xF3;digo de <code>Loader</code> lo puedes encontrar en <code>src/lib/loader.js</code>. Ver&#xE1;s que\nest&#xE1; implementado como un objeto con una serie de m&#xE9;todos que comparten estado\na trav&#xE9;s del uso de la pseudovariable <code>this</code>.</p>\n<p>La tarea es refactorizar <code>Loader</code> de tal forma que sea una funci&#xF3;n que crea un\nobjeto con los m&#xE9;todos <code>loadImage</code> y <code>getImage</code>. La implementaci&#xF3;n debe hacer\nuso de estilo funcional, compartiendo estado de forma expl&#xED;cita a trav&#xE9;s de\nargumentos en vez de <code>this</code>.</p>\n<p>El repositorio ya incluye una serie de tests unitarios que <code>Loader</code> debe pasar\npara cumplir con todos los requisitos.</p>\n<pre><code class=\"lang-sh\">npm install\nnpm test\n</code></pre>\n"
          },
          "02-closing": {
            "title": "Cierre",
            "type": "seminario",
            "format": "guiado",
            "duration": 15
          }
        }
      },
      "03-hof": {
        "title": "Higher Order Functions",
        "bonus": false,
        "description": "<p>Las <strong>funciones de orden superior</strong> (<em>Higher Order Functions</em> en inglés), no son\nmás que funciones que reciben otras funciones como argumentos o que retornan una\nfunción. En esta unidad veremos este tipo de funciones en acción, incluyendo\nusos más avanzados como <strong>aplicación parcial</strong> y <strong>currying</strong>.</p>\n",
        "parts": {
          "00-opening": {
            "title": "Apertura",
            "type": "seminario",
            "format": "guiado",
            "duration": 15,
            "body": "<h2 id=\"-por-qu-aprender-esto-\">&#xBF;Por qu&#xE9; aprender esto?</h2>\n<p>Las funciones de orden superior (Higher Order Functions) son simplemente\nfunciones que reciben funciones como argumentos o que devuelven una funci&#xF3;n como\nvalor de retorno. Este tipo de funciones son muy comunes en JavaScript, tanto\nen utilidades del lenguage (por ejemplo los m&#xE9;todos de arrays <code>map</code>, <code>filter</code> o\n<code>reduce</code>) como en <em>event handlers</em> o composici&#xF3;n de funciones.</p>\n<p>Todo desarrollador JavaScript debe conocer en profundidad estos conceptos para\npoder desenvolverse en el lenguaje.</p>\n<h2 id=\"hoja-de-ruta\">Hoja de ruta</h2>\n<h3 id=\"semana-1\">Semana 1</h3>\n<ul>\n<li>Sesi&#xF3;n 1: presencial 3h =&gt; Funciones puras e inmutabilidad**</li>\n<li>Sesi&#xF3;n 2: self-paced 2h =&gt; Refactorizar <code>Loader</code></li>\n</ul>\n<h3 id=\"semana-2\">Semana 2</h3>\n<ul>\n<li>Pre-tarea: Lectura <em>Higher Order Functions</em> (Unidad 03)</li>\n<li><strong>Sesi&#xF3;n 3: presencial 3h =&gt; Higher Order Functions</strong></li>\n<li>Sesi&#xF3;n 4: self-paced 2h =&gt; Refactorizar ???</li>\n</ul>\n<h3 id=\"semana-3\">Semana 3</h3>\n<ul>\n<li>Pre-tarea: Lectura <em>Recursividad</em> (Unidad 05)</li>\n<li>Sesi&#xF3;n 5: presencial 3h =&gt; Control de flujo (recursi&#xF3;n y asincron&#xED;a)</li>\n<li>Sesi&#xF3;n 6: self-paced 2h =&gt; Refactorizar ???</li>\n</ul>\n<h3 id=\"semana-4\">Semana 4</h3>\n<ul>\n<li>Pre-tarea: Implementaci&#xF3;n, refactoring, pull request</li>\n<li>Sesi&#xF3;n 7: presencial 3h =&gt; Code review + Demos de proyectos</li>\n<li>Sesi&#xF3;n 8: self-paced 2h =&gt; Retrospectiva</li>\n</ul>\n<h2 id=\"gu-a-de-preguntas-y-conceptos-clave\">Gu&#xED;a de preguntas y conceptos clave</h2>\n<p>Cuando empezamos a estudiar un tema nuevo, es &#xFA;til tener una idea de los\nconceptos m&#xE1;s importantes de lo que vamos a aprender y de los temas centrales\nque debemos prestar particular atenci&#xF3;n.</p>\n<p>A continuaci&#xF3;n te presentamos una serie de preguntas que debes ser capaz de\nresponder al terminar esta unidad. Utiliza estas preguntas como gu&#xED;a para\norientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida\nque avanzas para validar que est&#xE1;s avanzando en la direcci&#xF3;n correcta. Que te\nsirva como un &quot;checklist&quot; que vas marcando a medida que vas progresando.</p>\n<ul>\n<li>Qu&#xE9; significa que las funciones son de primera clase en JavaScript?</li>\n<li>Qu&#xE9; es una funci&#xF3;n de orden superior</li>\n<li>Qu&#xE9; es una funci&#xF3;n de primer orden</li>\n<li>Qu&#xE9; es la t&#xE9;cnica de la aplicaci&#xF3;n parcial</li>\n<li>Qu&#xE9; es el <em>currying</em> en programaci&#xF3;n funcional</li>\n</ul>\n"
          },
          "01-hof": {
            "title": "Funciones de orden superior (Higher Order Functions)",
            "type": "lectura",
            "format": "self-paced",
            "duration": 30,
            "body": "<p>Una funci&#xF3;n de orden superior se adhiere a una definici&#xF3;n muy espec&#xED;fica:</p>\n<ul>\n<li>Toma una funci&#xF3;n como argumento, o ...</li>\n<li>Devuelve una funci&#xF3;n como resultado</li>\n</ul>\n<p>Veamos entonces algunos ejemplos de funciones que toman otras funciones como\nargumento, ver&#xE1;s que este patr&#xF3;n es palpable en el estilo de programaci&#xF3;n\nfuncional.</p>\n<h2 id=\"funciones-que-toman-otras-funciones\">Funciones que toman otras funciones</h2>\n<p>Ya has visto un mont&#xF3;n de funciones que toman otras funciones, quiz&#xE1; las m&#xE1;s\nprominentes hasta ahora son <code>map</code>, <code>reduce</code>, y <code>filter</code>. Todas estas funciones\nse adhieren a la definici&#xF3;n de orden superior ya que reciben una funci&#xF3;n como\nargumento. Ahora exploremos este concepto en m&#xE1;s detalle y veamos su importancia\nen el contexto de la programaci&#xF3;n funcional.</p>\n<h3 id=\"pensando-en-pasar-funciones-max-finder-y-best-\">Pensando en pasar funciones: <code>max</code>, <code>finder</code> y <code>best</code></h3>\n<p>Empecemos con un ejemplo. Muchos lenguajes de programaci&#xF3;n incluyen una funci&#xF3;n\nllamada algo como <code>max</code>, que se utiliza para encontrar el valor m&#xE1;s grande\n(generalmente de un n&#xFA;mero) en una lista o una matriz.</p>\n<p>De hecho, m&#xF3;dulos populares como <a href=\"https://lodash.com\" target=\"_blank\">Lodash</a> o\n<a href=\"http://ramdajs.com/\" target=\"_blank\">Ramda</a> incluyen una funci&#xF3;n que realiza esta misma tarea:</p>\n<pre><code class=\"lang-js\">const _ = require(&apos;lodash&apos;)\n\n_.max([1, 2, 3, 4, 5]);\n// =&gt; 5\n\n_.max([1, 2, 3, 4.75, 4.5])\n// =&gt; 4.75\n\nMath.max.apply(null, [1, 2, 3, 4.75, 4.5])\n// =&gt; 4.75\n\nMath.max(1, 2, 3, 4.75, 4.5)\n// =&gt; 4.75\n</code></pre>\n<p>No hay nada sorprendente en ninguno de los resultados, pero hay una limitaci&#xF3;n\nparticular en este caso de uso. Es decir, &#xBF;qu&#xE9; pasa si queremos encontrar el\nvalor m&#xE1;ximo en una matriz de objetos en lugar de n&#xFA;meros? Afortunadamente,\n<code>_.max</code> es una funci&#xF3;n de orden superior que toma un segundo argumento opcional.\nEste segundo argumento es, como habr&#xE1;s adivinado, una funci&#xF3;n que se utiliza\npara generar un valor num&#xE9;rico a partir del objeto que se le suministra. Por\nejemplo:</p>\n<pre><code class=\"lang-js\">const people = [{name: &quot;Fred&quot;, age: 65}, {name: &quot;Lucy&quot;, age: 36}]\n\n_.max(people, p =&gt; p.age)\n// =&gt; { name: &apos;Fred&apos;, age: 65 }\n</code></pre>\n<p>Esta es una manera muy &#xFA;til de construir funciones porque en lugar de enfocarse\nen la comparaci&#xF3;n de valores num&#xE9;ricos, <code>_.max</code> proporciona una forma arbitraria\nde comparar objetos. Sin embargo, esta funci&#xF3;n sigue siendo algo limitada ya que\nla comparaci&#xF3;n se hace a trav&#xE9;s del operador <em>mayor que</em> (<code>&gt;</code>).</p>\n<p>Creemos una nueva funci&#xF3;n llamada <code>finder</code> que tome dos funciones: una que\nconstruya el valor comparable y la otra que compare dos valores y retorne el\n&quot;mejor&quot; valor de los dos.</p>\n<pre><code class=\"lang-js\">const finder = (valueFun, bestFun, coll) =&gt;\n  _.reduce(coll, (best, current) =&gt; {\n    const bestValue = valueFun(best)\n    const currentValue = valueFun(current)\n    return (bestValue === bestFun(bestValue, currentValue)) ? best : current\n  })\n</code></pre>\n<p>Ahora, usando la funci&#xF3;n <code>finder</code>, la operaci&#xF3;n <code>_.max</code> se puede\nsimular de la siguiente forma:</p>\n<pre><code class=\"lang-js\">finder(_.identity, Math.max, [1, 2, 3, 4, 5])\n// =&gt; 5\n</code></pre>\n<p>En este &#xFA;ltimo ejemplo nota el uso de la funci&#xF3;n <code>_.identity</code>, dicha funci&#xF3;n\ns&#xF3;lo toma un valor y lo devuelve. Parece poco in&#xFA;til, &#xBF;verdad?, pero en el\n&#xE1;mbito de la programaci&#xF3;n funcional es necesario pensar en t&#xE9;rminos de\nfunciones.</p>\n<p>En cualquier caso, ahora con <code>finder</code> podemos usar diferentes funciones para\nadaptarnos a cada caso:</p>\n<pre><code class=\"lang-js\">const plucker = field =&gt; obj =&gt; obj &amp;&amp; obj[field]\n\nfinder(plucker(&apos;age&apos;), Math.max, people)\n// =&gt; { name: &apos;Fred&apos;, age: 65 }\n\nfinder(plucker(&apos;name&apos;), (x, y) =&gt; (x.charAt(0) === &quot;L&quot;) ? x : y, people)\n// =&gt; { name: &apos;Lucy&apos;, age: 36 }\n</code></pre>\n<p>La &#xFA;ltima funci&#xF3;n filtra nombres que comiencen con la letra <code>L</code>.</p>\n<p>La implementaci&#xF3;n de <code>finder</code> es corta y funciona como esperamos, pero duplica\nalguna l&#xF3;gica para aportar m&#xE1;xima flexibilidad. Observa una similitud en la\nimplementaci&#xF3;n de <code>finder</code> y la l&#xF3;gica de comparaci&#xF3;n para la funci&#xF3;n de primera\nclase de <em>best-value</em>:</p>\n<pre><code class=\"lang-js\">// en finder\nreturn (bestValue === bestFun(bestValue, currentValue)) ? best : current\n\n// en la funci&#xF3;n best-value\nreturn (x.charAt(0) === &quot;L&quot;) ? x : y\n</code></pre>\n<p>Nota que la l&#xF3;gica es exactamente la misma en ambos casos. Es decir, ambos\nalgoritmos est&#xE1;n devolviendo un valor u otro basado en cierta condici&#xF3;n. La\nimplementaci&#xF3;n de <code>finder</code> puede ser ajustada haciendo dos suposiciones:</p>\n<ul>\n<li>La funci&#xF3;n <em>best-value</em> devuelve <code>true</code> si el primer argumento es &quot;mejor&quot; que\nel segundo argumento</li>\n<li>Que la funci&#xF3;n <em>best-value</em> sabe c&#xF3;mo &quot;descubrir&quot; sus argumentos</li>\n</ul>\n<p>Teniendo en cuenta estas suposiciones, se logra la siguiente implementaci&#xF3;n:</p>\n<pre><code class=\"lang-js\">const best = (fun, coll) =&gt; _.reduce(coll, (x, y) =&gt; fun(x, y) ? x : y)\n\nbest((x, y) =&gt; x &gt; y, [1, 2, 3, 4, 5])\n// =&gt; 5\n</code></pre>\n<p>Con la l&#xF3;gica duplicada eliminada, ahora tenemos una soluci&#xF3;n m&#xE1;s elegante. De\nhecho, el ejemplo anterior muestra una vez m&#xE1;s que el patr&#xF3;n\n<code>best((x, y) =&gt; x &gt; y, ...)</code> proporciona la misma funcionalidad que <code>_.max</code> o\nincluso el <code>Math.max.apply(null, [1, 2, 3, 4, 5])</code>. Los programadores\nfuncionales tienden a capturar patrones como &#xE9;ste para crear funciones &#xFA;tiles.</p>\n<h2 id=\"funciones-que-devuelven-otras-funciones\">Funciones que devuelven otras funciones</h2>\n<p>Ya hemos visto funciones que retornan otras funciones, la m&#xE1;s reciente ha sido\n<code>plucker</code>. Como es de suponer, todas estas funciones son funciones de orden\nsuperior. Ahora hablaremos m&#xE1;s profundamente sobre las funciones de orden\nsuperior que devuelven (y a veces tambi&#xE9;n toman) funciones y cierres/closures.\nPara empezar, definamos <code>repeatedly</code>, una funci&#xF3;n que repite un c&#xE1;lculo\ncomputacional dado por otra funci&#xF3;n cierto n&#xFA;mero de veces.</p>\n<pre><code class=\"lang-js\">const repeatedly = (times, fun) =&gt; _.map(_.range(times), fun)\n</code></pre>\n<p>Utilicemos una funci&#xF3;n que ignore sus argumentos y en su lugar devuelve una\nconstante y con ella alimentemos a <code>repeatedly</code>:</p>\n<pre><code class=\"lang-js\">repeatedly(3, () =&gt; &quot;Odelay!&quot;)\n// =&gt; [&quot;Odelay!&quot;, &quot;Odelay!&quot;, &quot;Odelay!&quot;]\n</code></pre>\n<p>El uso de una funci&#xF3;n que devuelve una constante es tan &#xFA;til que es casi un\npatr&#xF3;n de dise&#xF1;o para la programaci&#xF3;n funcional y a menudo se llama simplemente\n<code>k</code>. Sin embargo, en aras de la claridad, lo llamaremos <code>always</code>; Se implementa\nde la siguiente manera:</p>\n<pre><code class=\"lang-js\">const always = value =&gt; () =&gt; value\n</code></pre>\n<p>La operaci&#xF3;n <code>always</code> es &#xFA;til para ilustrar algunos puntos sobre\nclosures/cierres. Primero, un cierre captura un solo valor (o referencia) y\ndevuelve repetidamente el mismo valor:</p>\n<pre><code class=\"lang-js\">let f = always(function(){})\n\nf() === f()\n// =&gt; true\n</code></pre>\n<p>Debido a que la funci&#xF3;n <code>always</code> produce un valor &#xFA;nico, se puede ver que desde\nuna invocaci&#xF3;n de <code>always</code> a otra, la funci&#xF3;n capturada vinculada a <code>value</code> es\nsiempre la misma.</p>\n<p>Cualquier funci&#xF3;n creada con <code>function</code> devolver&#xE1; una instancia &#xFA;nica,\nindependientemente del contenido de su cuerpo. El uso de <code>(function () {})</code> es\nuna forma r&#xE1;pida de garantizar que se generan valores &#xFA;nicos. Teniendo esto en\nmente, una segunda nota importante acerca de los cierres es que cada nuevo\ncierre captura un valor diferente que todos los dem&#xE1;s:</p>\n<pre><code class=\"lang-js\">let g = always(function(){})\n\nf() === g()\n// =&gt; false\n</code></pre>\n<p>Mantener estas dos reglas en mente al usar closures/cierres ayudar&#xE1; a evitar la\nconfusi&#xF3;n.</p>\n<p>Continuemos con el ejemplo y reemplacemos la funci&#xF3;n an&#xF3;nima que usamos\npreviamente con <code>always</code>:</p>\n<pre><code class=\"lang-js\">repeatedly(3, always(&quot;Odelay!&quot;))\n// =&gt; [&quot;Odelay!&quot;, &quot;Odelay!&quot;, &quot;Odelay!&quot;]\n</code></pre>\n<p>La funci&#xF3;n <code>always</code> es lo que se conoce como un combinador. Esta lecci&#xF3;n no se\ncentrar&#xE1; en gran medida en los combinadores, aunque ver&#xE1;s que se utilizan en\nbases de c&#xF3;digo construido en un estilo funcional.</p>\n<p>Antes de seguir adelante, mostraremos la implementaci&#xF3;n de otra funci&#xF3;n que\nretorna otra funci&#xF3;n, <code>invoker</code>, que toma un m&#xE9;todo y devuelve una funci&#xF3;n que\ninvocar&#xE1; ese m&#xE9;todo en cualquier objeto dado. Observalo a continuaci&#xF3;n:</p>\n<pre><code class=\"lang-js\">// Helpers\nconst existy = x =&gt; x != null\nconst truthy = x =&gt; (x !== false) &amp;&amp; existy(x)\nconst doWhen = (cond, action) =&gt; truthy(cond) ? action() : undefined\n\nconst fail = thing =&gt; {\n  throw new Error(thing)\n}\n\nconst invoker = (name, method) =&gt;\n  (target, ...args) =&gt; {\n    if (!existy(target)) {\n      fail(&quot;Must provide a target&quot;)\n    }\n\n    const targetMethod = target[name]\n\n    return doWhen((existy(targetMethod) &amp;&amp; method === targetMethod), () =&gt;\n      targetMethod.apply(target, args)\n   )\n  }\n</code></pre>\n<p>La forma de <code>invoker</code> es muy similar a <code>always</code>, es decir, es una funci&#xF3;n que\ndevuelve una funci&#xF3;n que utiliza un argumento original, <code>method</code>, durante una\ninvocaci&#xF3;n posterior. La funci&#xF3;n devuelta en este caso es un closure/cierre.\nSin embargo, en lugar de devolver una constante, <code>invoker</code> realiza alguna\nacci&#xF3;n especializada basada en el valor de la llamada original. El uso del\n<code>invoker</code> es el siguiente:</p>\n<pre><code class=\"lang-js\">const rev = invoker(&apos;reverse&apos;, Array.prototype.reverse)\n\n_.map([[1, 2, 3]], rev)\n// =&gt; [[3, 2, 1]]\n</code></pre>\n<p>Si bien es perfectamente leg&#xED;timo invocar directamente un m&#xE9;todo sobre una\ninstancia, en estilo funcional preferimos las funciones que se centran en la\naplicaci&#xF3;n de argumentos.</p>\n<h2 id=\"referencias\">Referencias</h2>\n<ul>\n<li><a href=\"http://shop.oreilly.com/product/0636920028857.do\" target=\"_blank\">Functional JavaScript</a> de\nMichael Fogus</li>\n</ul>\n"
          },
          "02-practice": {
            "title": "Ejercicios de Higher Order Functions",
            "type": "practice",
            "format": "self-paced",
            "duration": 10,
            "exercises": {
              "01-repeat": {
                "title": "Repite una operación `n` número de veces",
                "env": "js",
                "body": "<p>Una funci&#xF3;n de orden superior (higher-order function) es una funci&#xF3;n que cumple\npor lo menos una de estas condiciones:</p>\n<ul>\n<li>Recibe una o m&#xE1;s funciones como input</li>\n<li>Devuelve una funci&#xF3;n</li>\n</ul>\n<p>Todas las dem&#xE1;s funciones son de primer orden (first order functions). [1]</p>\n<p>A diferencia de muchos otros lenguajes con caracter&#xED;sticas imperativas,\nJavaScript nos permite usar higher-order functions ya que tiene funciones\n&quot;first-class&quot;. Lo que significa que las funciones pueden ser tratadas como\ncualquier otro valor en JavaScript: igual que Strings o Numbers, valores de tipo\nFunction pueden ser almacenados en variables, propiedades de objetos o pasados\na otras funciones como argumentos. Los valores de tipo Function de hecho son\nObjects (que heredan de <code>Function.prototype</code>), as&#xED; que podemos incluso a&#xF1;adir\npropiedades y asignar valores igual que en cualquir otro objeto.</p>\n<p>La principal diferencia entre las funciones y el resto de valores en JavaScript\nes la sint&#xE1;xis de invocaci&#xF3;n: si una referencia a una funci&#xF3;n est&#xE1; seguida de\npar&#xE9;ntesis y opcionalmente una lista de argumentos separados por comas:\n<code>someFunctionValue(arg1, arg2, etc)</code>, entonces el cuerpo de la funci&#xF3;n ser&#xE1;\nejecutada con los argumentos pasados (si hubiere).</p>\n<p>En este ejercicio vamos a demostrar que las funciones pueden ser pasadas como\nvalores. Te vamos a pasar una funci&#xF3;n como argumento.</p>\n<h2 id=\"tarea\">Tarea</h2>\n<p>Implementa una funci&#xF3;n que reciba una funci&#xF3;n como primer argumento, y un n&#xFA;mero\n<code>num</code> como segundo argumento. La funci&#xF3;n debe ejecutar la funci&#xF3;n <code>num</code> veces.</p>\n<p>Usa el boilerplate provisto para empezar. Todos (o casi todos) los ejercicios\nincluir&#xE1;n un boilerplate.</p>\n<h2 id=\"argumentos\">Argumentos</h2>\n<ul>\n<li>operation: Una funci&#xF3;n, no recibe argumentos, no retorna ning&#xFA;n valor &#xFA;til.</li>\n<li>num: el n&#xFA;mero de veces que queremos invocar <code>operation</code></li>\n</ul>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions_and_function_scope\" target=\"_blank\">MDN - Functions and function scope</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\" target=\"_blank\">MDN - Function.prototype</a></li>\n</ul>\n<h2 id=\"pistas\">Pistas</h2>\n<ul>\n<li>No lo des demasiadas vueltas, el c&#xF3;digo debe ser muy simple.</li>\n<li>No pasa nada si usas un loop. Bonus para quien implemente usando recursi&#xF3;n.</li>\n<li>No tienes que usar console.log para nada.</li>\n</ul>\n",
                "files": {
                  "Ym9pbGVycGxhdGU=": {
                    "cmVwZWF0Lmpz": "function repeat(operation, num) {\n  // TÚ SOLUCIÓN AQUÍ\n}\n\n// No borres la línea de abajo\nmodule.exports = repeat;\n"
                  },
                  "c29sdXRpb24=": {
                    "cmVwZWF0Lmpz": "function repeat(operation, num) {\n  if (!num) {\n    return;\n  }\n  operation();\n  repeat(operation, num - 1);\n}\n\n// No borres la línea de abajo\nmodule.exports = repeat;\n"
                  },
                  "dGVzdA==": {
                    "cmVwZWF0LnNwZWMuanM=": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Submission = require('../solution/repeat');\n\n\ndescribe('repeat()', () => {\n\n  it('debería invocar la función 5 veces cuando n es 5', () => {\n    let calls = 0;\n    const fn = () => calls++;\n    Submission(fn, 5);\n    Assert.equal(calls, 5);\n  });\n\n  it('debería invocar la función 8 veces cuando n es 8', () => {\n    let calls = 0;\n    const fn = () => calls++;\n    Submission(fn, 8);\n    Assert.equal(calls, 8);\n  });\n\n  it('no debería invocar la función cuando n es 0', () => {\n    let calls = 0;\n    const fn = () => calls++;\n    Submission(fn, 0);\n    Assert.equal(calls, 0);\n  });\n\n  it('debería retornar undefined', () => {\n    const fn = () => true;\n    Assert.equal(Submission(fn, 5), undefined);\n  });\n\n});\n"
                  }
                }
              }
            }
          },
          "03-partial-application": {
            "title": "Aplicación parcial",
            "type": "lectura",
            "format": "self-paced",
            "duration": 10,
            "body": "<p>Quiz&#xE1; la mejor manera de explicar este concepto es verlo directamente en acci&#xF3;n.\nImagina la siguiente funci&#xF3;n:</p>\n<pre><code class=\"lang-js\">const greetPart = greeting =&gt; name =&gt; `${greeting}, ${name}`\n\nconst greetHello = greetPart(&apos;Hello&apos;)\n\ngreetHello(&apos;Heidi&apos;)\n// =&gt; &apos;Hello, Heidi&apos;\n</code></pre>\n<p>La funci&#xF3;n <code>greetPart()</code> recibe un argumento (<code>greeting</code>) y retorna una funci&#xF3;n,\nque a su vez recibe un argumento (<code>name</code>) y retorna un string. Al invocar\n<code>greetPart(&apos;Hello&apos;)</code> estamos parcialmente aplicando el primer argumento\n(<code>greeting</code>), para m&#xE1;s tarde invocar <code>greetHello()</code> con el argumento que falta\n(<code>name</code>).</p>\n<p>Las funciones parcialmente aplicadas no necesariamente interactuan con un\nargumento a la vez, pueden interactuar con cualquier n&#xFA;mero de argumentos\nparcialmente aplicados que son almacenados para su posterior ejecuci&#xF3;n.</p>\n<h2 id=\"aplicaci-n-parcial-sobre-uno-y-dos-argumentos-conocidos\">Aplicaci&#xF3;n parcial sobre uno y dos argumentos conocidos</h2>\n<p>Podr&#xED;amos crear una funci&#xF3;n que nos permita aplicar parcialmente un argumento\na cualquier funci&#xF3;n que espere m&#xE1;s de un argumento. Considera el siguiente\nc&#xF3;digo:</p>\n<pre><code class=\"lang-js\">// Funci&#xF3;n que espera m&#xE1;s de un argumento\nconst greet = (greeting, name) =&gt; `${greeting}, ${name}`\n\n// Utilidad para aplicar parcialmente primer argumento\nconst partial1 = (fun, arg1) =&gt;\n  (...args) =&gt; {\n    const params = Array.prototype.concat(arg1, args)\n    return fun.apply(fun, params)\n  }\n\n// Aplica parcialmente &apos;Hello&apos; como primer argumento de `greet`\nconst greetHello = partial1(greet, &apos;Hello&apos;)\n\ngreetHello(&apos;Heidi&apos;)\n// =&gt; &apos;Hello, Heidi&apos;\n</code></pre>\n<p><strong>NOTA</strong>: Tambi&#xE9;n es posible utilizar <code>Function.prototype.bind()</code> para\nimplementar <code>partial1</code> reemplazando su cuerpo por <code>fun.bind(null, arg1)</code></p>\n<p>De nuevo hemos logrado recrear la operaci&#xF3;n de la funci&#xF3;n <code>greetHello</code> al\ncomponer una funci&#xF3;n a partir de otra dado un argumento previo de\n&quot;configuraci&#xF3;n&quot;. De igual manera pudimos haber hecho lo siguiente:</p>\n<pre><code class=\"lang-js\">const partial2 = (fun, arg1, arg2) =&gt;\n  (...args) =&gt; {\n    const params = Array.prototype.concat(arg1, arg2, args)\n    return fun.apply(fun, params)\n  }\n\nconst greetHelloHeidi = partial2(greet, &apos;Hello&apos;, &apos;Heidi&apos;)\n\ngreetHelloHeidi()\n// =&gt; &apos;Hello, Heidi&apos;\n</code></pre>\n<h2 id=\"aplicaci-n-parcial-sobre-un-n-mero-arbitrario-de-argumentos\">Aplicaci&#xF3;n parcial sobre un n&#xFA;mero arbitrario de argumentos</h2>\n<p>La aplicaci&#xF3;n parcial de un n&#xFA;mero arbitrario de argumentos es ciertamente una\nestrategia de composici&#xF3;n. Afortunadamente, la implementaci&#xF3;n de la funci&#xF3;n\n<code>partial</code> no es significativamente m&#xE1;s compleja que <code>partial1</code> y <code>partial2</code>. De\nhecho, aplicaremos la misma base:</p>\n<pre><code class=\"lang-js\">const partial = (fun, ...args) =&gt;\n  (...newArgs) =&gt; {\n    const params = Array.prototype.concat(args, newArgs)\n    return fun.apply(fun, params)\n  }\n\nconst greeter = (greeting, separator, emphasis, name) =&gt;\n  `${greeting}${separator}${name}${emphasis}`\n\nconst greetHello = partial(greeter, &apos;Hello&apos;, &apos;, &apos;, &apos;.&apos;)\n\ngreetHello(&apos;Heidi&apos;)\n// =&gt; &apos;Hello, Heidi.&apos;\n</code></pre>\n<p>Como pudiste notar, el principio es el mismo, <code>partial</code> captura cierto n&#xFA;mero\nde argumentos y retorna una funci&#xF3;n que los usa como argumentos prefijo para su\nllamada final.</p>\n<p>Es importante hacer mencionar que podemos realizar aplicaci&#xF3;n parcial de manera\nsucinta por medio de <code>bind</code>, por ejemplo:</p>\n<pre><code class=\"lang-js\">const greeter = (greeting, separator, emphasis, name) =&gt;\n  `${greeting}${separator}${name}${emphasis}`\n\nconst greetHello = greeter.bind(null, &apos;Hello&apos;, &apos;, &apos;, &apos;.&apos;)\n\ngreetHello(&apos;Heidi&apos;)\n// =&gt; &apos;Hello, Heidi.&apos;\n</code></pre>\n<p>Finalmente, es importante mencionar que en este caso la funci&#xF3;n que estamos\nparcialmente aplicando espera un n&#xFA;mero fijo de argumentos, el hecho que pueda\naceptar cualquier cantidad de argumentos a veces puede causar confusi&#xF3;n, fijate\nen el siguiente ejemplo:</p>\n<pre><code class=\"lang-js\">greeter.bind(null, &apos;Hello&apos;, &apos;, &apos;, &apos;.&apos;, &apos;Heidi&apos;, &apos;how&apos;, &apos;are&apos;, &apos;you&apos;, &apos;?&apos;)()\n// =&gt; &apos;Hello, Heidi.&apos;\n</code></pre>\n<p>Nuestra funci&#xF3;n <code>greeter</code> espera 4 argumentos, en este caso el resto de los\nargumentos pasados simplemente son ignorados.</p>\n<h2 id=\"referencias\">Referencias</h2>\n<ul>\n<li><a href=\"http://shop.oreilly.com/product/0636920028857.do\" target=\"_blank\">Functional JavaScript</a> de\nMichael Fogus</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\" target=\"_blank\">Array.prototype.concat()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\">Function.prototype.bind()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\" target=\"_blank\">Function.prototype.apply()</a></li>\n</ul>\n"
          },
          "04-practice": {
            "title": "Ejercicios de aplicación parcial",
            "type": "practice",
            "format": "self-paced",
            "duration": 10,
            "exercises": {
              "02-logger": {
                "title": "Without bind",
                "env": "js",
                "body": "<p>La aplicaci&#xF3;n parcial nos permite crear nuevas funciones a partir de funciones\nexistentes, a la vez que fijamos algunos argumentos. Despues de fijar los\nargumentos para ser parcialmente aplicados, tenemos una nueva funci&#xF3;n lista para\nrecibir el resto de los argumentos y quiz&#xE1;s ejecutar la funci&#xF3;n original.</p>\n<p>M&#xE1;s formalmente: La aplicaci&#xF3;n parcial hace referencia al proceso de fijar un\nn&#xFA;mero de argumentos a una funci&#xF3;n, produciendo otra de menor &quot;arity&quot;.</p>\n<h2 id=\"tarea\">Tarea</h2>\n<p>Usa aplicaci&#xF3;n parcial para crear una funci&#xF3;n <code>logger</code> que a&#xF1;ada un &quot;namespace&quot;\n(un string) al principio del resultado.</p>\n<p>Tu implementaci&#xF3;n debe recibir un string <code>namespace</code> y retornar una funci&#xF3;n que\ncombine mensajes separados por espacios con el namespace al principio.</p>\n<p>Aseg&#xFA;rate de que la funci&#xF3;n que retorne <code>logger</code> haga uso de <em>todos</em> los\nargumentos que le pasen.</p>\n<h2 id=\"argumentos\">Argumentos</h2>\n<ul>\n<li>namespace: un String con el nombre del namespace.</li>\n</ul>\n<h2 id=\"ejemplo\">Ejemplo</h2>\n<pre><code class=\"lang-js\">var info = logger(&apos;INFO:&apos;)\ninfo(&apos;this is an info message&apos;)\n// INFO: this is an info message\n\nvar warn = logger(&apos;WARN:&apos;)\nwarn(&apos;this is a warning message&apos;, &apos;with more info&apos;)\n// WARN: this is a warning message with more info\n</code></pre>\n<h2 id=\"requisitos\">Requisitos</h2>\n<ul>\n<li>No uses <code>Function#bind</code> ni <code>Function#apply</code></li>\n</ul>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Partial_application\" target=\"_blank\">Wikipedia - Partial application</a></li>\n</ul>\n",
                "files": {
                  "Ym9pbGVycGxhdGU=": {
                    "bG9nZ2VyLmpz": "const logger = null;\n\nmodule.exports = logger;\n"
                  },
                  "c29sdXRpb24=": {
                    "bG9nZ2VyLmpz": "const logger = namespace => (...args) => `${namespace} ${args.join(' ')}`;\n\nmodule.exports = logger;\n"
                  },
                  "dGVzdA==": {
                    "bG9nZ2VyLnNwZWMuanM=": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst Submission = require('../solution/logger');\n\n\ndescribe('logger()', () => {\n\n  it('debería exportar una función', () => {\n    Assert.equal(typeof Submission, 'function');\n  });\n\n  it('debería combinar namespace + 1 string', () => {\n    const info = Submission('INFO:');\n    Assert.equal(info('this is an info message'), 'INFO: this is an info message');\n  });\n\n  it('debería combinar namespace + 2 strings', () => {\n    const warn = Submission('WARN:');\n    Assert.equal(\n      warn('this is a warning message', 'with more info'),\n      'WARN: this is a warning message with more info'\n    );\n  });\n\n  it('no debería usar Function.prototype.bind', () => {\n    const spy = Sinon.spy(Function.prototype, 'bind');\n    Submission('ERROR:')('foo');\n    Assert.equal(spy.callCount, 0);\n    spy.restore();\n  });\n\n})\n"
                  }
                }
              },
              "01-bound-logger": {
                "title": "With bind",
                "env": "js",
                "body": "<p><strong>Usa Function#bind</strong> para implementar una funci&#xF3;n <code>logger</code> que nos permita\nseparar mensajes en diferentes &#xE1;mbitos (namespaces).</p>\n<p>Tu implementaci&#xF3;n debe exportar dos funciones con las siguientes <em>firmas</em>:</p>\n<ul>\n<li><code>log(str1, str2, str3, ...)</code>: Retorna un string con los strings de entrada\nconcatenados y separados por espacios.</li>\n<li><code>logger(namespace)</code>: Retorna una funci&#xF3;n que combina un se comporta como <code>log</code>\npero siempre a&#xF1;ade <code>namespace</code> al principio.</li>\n</ul>\n<p>Aseg&#xFA;rate de que la funci&#xF3;n que retorne <code>logger</code> haga uso de <em>todos</em> los\nargumentos que le pasen.</p>\n<h2 id=\"ejemplo\">Ejemplo</h2>\n<pre><code class=\"lang-js\">const { logger } = require(&apos;./tu-modulo&apos;);\n\nconst info = logger(&apos;INFO:&apos;)\ninfo(&apos;this is an info message&apos;)\n// =&gt; &apos;INFO: this is an info message&apos;\n\nvar warn = logger(&apos;WARN:&apos;)\nwarn(&apos;this is a warning message&apos;, &apos;with more info&apos;)\n// =&gt; &apos;WARN: this is a warning message with more info&apos;\n</code></pre>\n<h2 id=\"requisitos\">Requisitos</h2>\n<ul>\n<li>Usar <code>Function#bind</code></li>\n<li>La funci&#xF3;n <code>logger()</code> debe hacer uso de <code>log</code>.</li>\n</ul>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\">Function.bind</a></li>\n</ul>\n",
                "files": {
                  "Ym9pbGVycGxhdGU=": {
                    "Ym91bmRMb2dnZXIuanM=": "exports.log = null;\n\nexports.logger = null;\n"
                  },
                  "c29sdXRpb24=": {
                    "Ym91bmRMb2dnZXIuanM=": "exports.log = (...args) => args.join(' ');\n\nexports.logger = namespace => exports.log.bind(null, namespace);\n"
                  },
                  "dGVzdA==": {
                    "Ym91bmRMb2dnZXIuc3BlYy5qcw==": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst Submission = require('../solution/boundLogger');\n\n\ndescribe('with bind', () => {\n\n  it('debería exportar log() y logger()', () => {\n    Assert.equal(typeof Submission.log, 'function');\n    Assert.equal(typeof Submission.logger, 'function');\n  });\n\n  describe('log()', () => {\n\n    [\n      [['foo'], 'foo'],\n      [['foo', 'foo'], 'foo foo'],\n      [['foo', 'bar', 'baz'], 'foo bar baz'],\n      [['foo', 'bar', 'baz', 1, 2, 3], 'foo bar baz 1 2 3'],\n    ].forEach(pair => {\n      it(`debería retornar \"${pair[1]}\" para [${pair[0]}]`, () => {\n        Assert.equal(Submission.log.apply(null, pair[0]), pair[1]);\n      });\n    });\n\n  });\n\n  describe('logger()', () => {\n\n    it('debería combinar namespace + 1 string', () => {\n      const info = Submission.logger('INFO:');\n      Assert.equal(info('this is an info message'), 'INFO: this is an info message');\n    });\n\n    it('debería combinar namespace + 2 strings', () => {\n      const warn = Submission.logger('WARN:');\n      Assert.equal(\n        warn('this is a warning message', 'with more info'),\n        'WARN: this is a warning message with more info'\n      );\n    });\n\n    it('debería usar Function.prototype.bind', () => {\n      const spy = Sinon.spy(Function.prototype, 'bind');\n      Submission.logger('ERROR:')('foo');\n      Assert.equal(spy.callCount, 1);\n      Assert.equal(spy.args[0][0], null);\n      Assert.equal(spy.args[0][1], 'ERROR:');\n      spy.restore();\n    });\n\n  });\n\n})\n"
                  }
                }
              }
            }
          },
          "05-currying": {
            "title": "Aplicando curry en JavaScript funcional",
            "type": "lectura",
            "format": "self-paced",
            "duration": 30,
            "body": "<p>La t&#xE9;cnica de definir funciones atadas a m&#xFA;ltiples par&#xE1;metros como una serie de\nfunciones anidadas que solo esperan un par&#xE1;metro fue popularizada por el\nmatem&#xE1;tico <a href=\"https://en.wikipedia.org/wiki/Haskell_Curry\" target=\"_blank\">Haskell Curry</a>, aunque inicialmente observada por <a href=\"https://en.wikipedia.org/wiki/Gottlob_Frege\" target=\"_blank\">Frege</a> en\n1893, a dicha cadena de funciones anidadas se les llama funciones curry o\n<em>curried functions</em>.</p>\n<h2 id=\"-qu-es-_currying_-\">&#xBF;Qu&#xE9; es <em>currying</em>?</h2>\n<p>En pocas palabras, <em>currying</em> es una t&#xE9;cnica que traduce la evaluaci&#xF3;n de una\nfunci&#xF3;n que toma m&#xFA;ltiples argumentos en una evaluaci&#xF3;n de una secuencia de\nfunciones, cada una de funciones de la secuencia espera un &#xFA;nico argumento.\n<em>Currying</em> est&#xE1; relacionado con el concepto de <a href=\"https://en.wikipedia.org/wiki/Partial_application\" target=\"_blank\">aplicaci&#xF3;n\nparcial</a>, pero no es lo mismo.</p>\n<p>Una funci&#xF3;n curry es una que retorna progresivamente una funci&#xF3;n m&#xE1;s espec&#xED;fica\npor cada uno de los argumentos dados hasta que ya no sean necesarios m&#xE1;s\npar&#xE1;metros. Una funci&#xF3;n parcialmente aplicada, por otra parte, es una funci&#xF3;n\nque es &quot;parcialmente&quot; ejecutada y est&#xE1; lista para su inmediata ejecuci&#xF3;n una vez\ndado el resto de los par&#xE1;metros esperados.</p>\n<p>El <em>currying</em> es elemental en la mayor&#xED;a de los lenguajes de programaci&#xF3;n\nfuncional, por ejemplo Haskell o Scala. A pesar que JavaScript ofrece soporte\npara algunas caracter&#xED;sticas funcionales, al menos en las versiones actuales, el\n<em>currying</em> no es una de ellas. Sin embargo, podemos <em>emular</em> este patr&#xF3;n con las\ncaracter&#xED;sticas actuales del lenguaje.</p>\n<p>Para darte una idea de c&#xF3;mo este concepto podr&#xED;a funcionar, vamos a crear\nnuestra primera funci&#xF3;n <em>curry</em> en JavaScript, utilizando la sintaxis familiar\npara construir la funcionalidad <em>currying</em> que queremos. Como ejemplo,\nimaginemos una funci&#xF3;n que salude a alguien por su nombre. Todos sabemos c&#xF3;mo\ncrear una funci&#xF3;n simple de saludo que toma un nombre y un saludo, y registra el\nsaludo con el nombre:</p>\n<pre><code class=\"lang-js\">const greet = (greeting, name) =&gt; `${greeting}, ${name}`\n\ntest(&apos;Should say Hello&apos;, () =&gt; {\n  expect(greet(&apos;Hello&apos;, &apos;Heidi&apos;)).toBe(&apos;Hello, Heidi&apos;)\n})\n</code></pre>\n<p>Esta funci&#xF3;n requiere que el nombre y el saludo se pasen como argumentos para\nque funcione correctamente. Pero podr&#xED;amos reescribir la funci&#xF3;n usando\n<em>currying</em> anidado simple, de modo que la funci&#xF3;n b&#xE1;sica s&#xF3;lo requiera un\nsaludo, y devuelve otra funci&#xF3;n que toma el nombre de la persona que queremos\nsaludar.</p>\n<h2 id=\"nuestro-primer-_curry_\">Nuestro primer <em>curry</em></h2>\n<pre><code class=\"lang-js\">const greetCurried = greeting =&gt; name =&gt; `${greeting}, ${name}`\n</code></pre>\n<p>Este peque&#xF1;o ajuste a la forma en que escribimos la funci&#xF3;n anterior nos permite\ncrear una nueva funci&#xF3;n para cualquier tipo de saludo, y pasar a esa nueva\nfunci&#xF3;n el nombre de la persona que queremos saludar:</p>\n<pre><code class=\"lang-js\">test(&apos;Should allow to reuse functions&apos;, () =&gt; {\n  const greetHello = greetCurried(&apos;Hello&apos;)\n\n  expect(greetHello(&apos;Heidi&apos;)).toBe(&apos;Hello, Heidi&apos;)\n  expect(greetHello(&apos;Eddie&apos;)).toBe(&apos;Hello, Eddie&apos;)\n})\n</code></pre>\n<p>Tambi&#xE9;n podemos llamar a la funci&#xF3;n en modo <em>curry</em> original directamente,\nsimplemente pasando cada uno de los par&#xE1;metros en un conjunto separado de\npar&#xE9;ntesis, uno despu&#xE9;s del otro:</p>\n<pre><code class=\"lang-js\">test(&apos;Should work with all the parameters&apos;, () =&gt; {\n  expect(greetCurried(&apos;Hi there&apos;)(&apos;Howard&apos;)).toBe(&apos;Hi there, Howard&apos;)\n})\n</code></pre>\n<h2 id=\"apliquemos-_curry_-a-todo\">Apliquemos <em>curry</em> a todo</h2>\n<p>Lo bueno es que ahora que hemos aprendido a modificar nuestra funci&#xF3;n\ntradicional para usar este enfoque para manejar los argumentos, podemos hacerlo\ncon tantos argumentos como queramos:</p>\n<pre><code class=\"lang-js\">const greetDeeplyCurried = greeting =&gt;\n  separator =&gt;\n    emphasis =&gt;\n      name =&gt;\n        `${greeting}${separator}${name}${emphasis}`\n</code></pre>\n<p>Tenemos la misma flexibilidad con cuatro argumentos que con dos. No importa lo\nlejos que vaya el anidamiento, podemos crear nuevas funciones personalizadas\npara saludar a tantas personas como escojamos de tantas maneras como nos\nconvenga:</p>\n<pre><code class=\"lang-js\">test(&apos;Should allow nested calls&apos;, () =&gt; {\n  const greetAwkwardly = greetDeeplyCurried(&apos;Hello&apos;)(&apos;...&apos;)(&apos;?&apos;)\n\n  expect(greetAwkwardly(&apos;Heidi&apos;)).toBe(&apos;Hello...Heidi?&apos;)\n  expect(greetAwkwardly(&apos;Eddie&apos;)).toBe(&apos;Hello...Eddie?&apos;)\n})\n</code></pre>\n<p>Adem&#xE1;s, podemos pasar tantos par&#xE1;metros como quisi&#xE9;ramos al crear variaciones\npersonalizadas de nuestra funci&#xF3;n <em>curry</em> original, creando nuevas funciones que\nson capaces de tomar el n&#xFA;mero apropiado de par&#xE1;metros adicionales, cada uno se\npasa por separado en su propio conjunto de par&#xE9;ntesis:</p>\n<pre><code class=\"lang-js\">test(&apos;Other variations&apos;, () =&gt; {\n  const sayHello = greetDeeplyCurried(&apos;Hello&apos;)(&apos;, &apos;)\n\n  expect(sayHello(&apos;.&apos;)(&apos;Heidi&apos;)).toBe(&apos;Hello, Heidi.&apos;)\n  expect(sayHello(&apos;.&apos;)(&apos;Eddie&apos;)).toBe(&apos;Hello, Eddie.&apos;)\n</code></pre>\n<p>Y se pueden definir variaciones subordinadas:</p>\n<pre><code class=\"lang-js\">  const askHello = sayHello(&apos;?&apos;)\n\n  expect(askHello(&apos;Heidi&apos;)).toBe(&apos;Hello, Heidi?&apos;)\n  expect(askHello(&apos;Eddie&apos;)).toBe(&apos;Hello, Eddie?&apos;)\n})\n</code></pre>\n<h2 id=\"aplicando-_curry_-a-funciones-tradicionales\">Aplicando <em>curry</em> a funciones tradicionales</h2>\n<p>Puedes ver lo poderoso que es este enfoque, especialmente si necesitas crear\nmuchas funciones personalizadas muy detalladas. El &#xFA;nico problema es la\nsintaxis, pues a medida que construyes estas funciones con <em>curry</em>, debes\nmantener las funciones devueltas anidadas, y llamarlas con nuevas funciones que\nrequieran varios conjuntos de par&#xE9;ntesis, cada uno conteniendo su propio\nargumento aislado. Se puede poner dif&#xED;cil y enredado.</p>\n<p>Antes de abordar la implementaci&#xF3;n de nuestra funci&#xF3;n <em>curry</em>, consideremos por\nejemplo que para toda funci&#xF3;n <code>f(x, y)</code>, existe una funci&#xF3;n <code>f&apos;</code> tal que\n<code>f&apos;(x)</code> es una funci&#xF3;n que puede ser aplicada a <code>y</code> que obtenga\n<code>(f&apos;(x))(y) = f(x, y)</code>.</p>\n<p>La funci&#xF3;n <code>f&apos;</code> del ejemplo anterior es llamada forma <em>curried</em> de la funci&#xF3;n.\nDesde una perspectiva de programaci&#xF3;n funcional, <em>currying</em> puede ser descrita\npor la funci&#xF3;n: <code>curry : ((a, b) -&gt; c) -&gt; (a -&gt; b -&gt; c)</code></p>\n<p>Ahora bien, un enfoque es crear una <strong>funci&#xF3;n de orden superior</strong> (<em>Higher\nOrder Function</em> en ingl&#xE9;s) que tome como argumento una funci&#xF3;n existente que\nfue escrita sin todas las devoluciones anidadas (<em>uncurried form</em>). Nuestra\nfunci&#xF3;n de orden superior debe retornar otra funci&#xF3;n que espera un solo\nargumento,...</p>\n<pre><code class=\"lang-js\">const curryIt = f =&gt; x =&gt; {\n  // ...\n}\n</code></pre>\n<p>Luego que se suministra dicho argumento se procede a verificar si el n&#xFA;mero de\nargumentos esperados (<code>Function.length</code>) por la funci&#xF3;n <em>uncurried</em> es igual o\nmenor a 1, de ser as&#xED; ejecuta dicha funci&#xF3;n, esta condici&#xF3;n particular tambi&#xE9;n\nnos servir&#xE1; como condici&#xF3;n de parada en nuestra llamada recursiva.</p>\n<pre><code class=\"lang-js\">const curryIt = f =&gt; x =&gt; {\n  if (f.length &lt;= 1) {\n    f(x)\n  } else {\n    // ...\n  }\n}\n</code></pre>\n<p>En cambio, si el n&#xFA;mero de par&#xE1;metros esperados es mayor a 1 debemos recurrir a\nla recursi&#xF3;n y aplicar de nuevo nuestra funci&#xF3;n de orden superior, en este\n&#xFA;ltimo caso pasaremos como argumento una nueva funci&#xF3;n equivalente, por medio\nde <code>Function.prototype.bind()</code>, a la funci&#xF3;n <em>uncurried</em> excepto por su\npar&#xE1;metro inicial. Algo similar a los siguiente:</p>\n<pre><code class=\"lang-js\">// funci&#xF3;n uncurried\nconst greet = (greeting, name) =&gt; `${greeting}, ${name}`\n// funci&#xF3;n equivalente a excepci&#xF3;n del argumento inicial\nconst greetWithGreeting = greet.bind(null, &apos;Hello&apos;) // [Function: bound greet]\ngreetWithGreeting(&apos;Heidi&apos;)\n// =&gt; &apos;Hello, Heidi&apos;\n</code></pre>\n<p>Sin mayor pre&#xE1;mbulo veamos el resultado final de nuestra funci&#xF3;n <code>curryIt</code>:</p>\n<pre><code class=\"lang-js\">const curryIt = f =&gt; x =&gt; f.length &lt;= 1 ? f(x) : curryIt(f.bind(null, x))\n</code></pre>\n<p>Para usar esto, le pasamos una referencia a una funci&#xF3;n que toma cualquier\nn&#xFA;mero de argumentos, junto con tantos de los argumentos como queremos\npre-poblar. Lo que recuperamos es una funci&#xF3;n que est&#xE1; a la espera de los\nargumentos restantes:</p>\n<pre><code class=\"lang-js\">const greeter = (greeting, separator, emphasis, name) =&gt;\n  `${greeting}${separator}${name}${emphasis}`\n\ntest(&apos;should return a curried equivalent of the provided function&apos;, () =&gt; {\n  const greetHello = curryIt(greeter)(&apos;Hello&apos;)(&apos;, &apos;)(&apos;.&apos;)\n\n  expect(greetHello(&apos;Heidi&apos;)).toBe(&apos;Hello, Heidi.&apos;)\n  expect(greetHello(&apos;Eddie&apos;)).toBe(&apos;Hello, Eddie.&apos;)\n</code></pre>\n<p>Y al igual que antes, no estamos limitados en t&#xE9;rminos del n&#xFA;mero de argumentos\nque queremos utilizar al construir funciones derivadas de nuestra funci&#xF3;n\noriginal que usa <em>curry</em>:</p>\n<pre><code class=\"lang-js\">  const greetGoodbye = curryIt(greeter)(&apos;Goodbye&apos;)(&apos;, &apos;)\n\n  expect(greetGoodbye(&apos;.&apos;)(&apos;Joe&apos;)).toBe(&apos;Goodbye, Joe.&apos;)\n})\n</code></pre>\n<h2 id=\"siendo-serios-sobre-_curry_\">Siendo serios sobre <em>curry</em></h2>\n<p>Nuestra peque&#xF1;a funci&#xF3;n <code>curryIt</code> no puede manejar todos los casos de borde,\ncomo los par&#xE1;metros faltantes u opcionales, pero hace un trabajo razonable\nsiempre y cuando permanezcamos estrictos sobre la sintaxis para pasar\nargumentos.</p>\n<p>Algunas bibliotecas funcionales de JavaScript como <a href=\"http://ramdajs.com/\" target=\"_blank\">Ramda</a> tienen funciones de\n<em>curry</em> m&#xE1;s flexibles que pueden dividir los par&#xE1;metros requeridos para una\nfunci&#xF3;n y permiten pasarlos individualmente o en grupos para crear variaciones\n<em>curry</em> personalizadas. Si deseas aplicar <em>curry</em> extensivamente, este es\nprobablemente el camino a seguir.</p>\n<p>Independientemente de c&#xF3;mo elijas a&#xF1;adir <em>curry</em> a tu programaci&#xF3;n, ya sea que\ndesee utilizar par&#xE9;ntesis anidados o prefieras incluir una funci&#xF3;n de transporte\nm&#xE1;s robusta, llegar a una convenci&#xF3;n de nomenclatura coherente para sus\nfunciones <em>curry</em> ayudar&#xE1; a hacer tu c&#xF3;digo m&#xE1;s legible. Te recomiendo que cada\nvariaci&#xF3;n derivada de una funci&#xF3;n tenga un nombre que deje claro c&#xF3;mo se\ncomporta, y qu&#xE9; argumentos est&#xE1; esperando.</p>\n<h2 id=\"orden-de-los-argumentos\">Orden de los argumentos</h2>\n<p>Una cosa que es importante tener en cuenta al momento de implementar <em>curry</em> es\nel orden de los argumentos. Usando el enfoque que hemos descrito, obviamente lo\nque t&#xFA; deseas es que el argumento que es m&#xE1;s probable que sea reemplazado de\nuna variaci&#xF3;n a la siguiente sea el &#xFA;ltimo argumento pasado a la funci&#xF3;n\noriginal.</p>\n<p>Pensar con antelaci&#xF3;n sobre el orden de los argumentos har&#xE1; que sea m&#xE1;s f&#xE1;cil\ndise&#xF1;ar un algoritmo para ser implementado con <em>curry</em>  y aplicarlo a tu\ntrabajo. Tener en cuenta el orden de tus argumentos en t&#xE9;rminos de menor a mayor\nprobabilidades de cambiar es un buen h&#xE1;bito al momento de dise&#xF1;ar funciones.</p>\n<h2 id=\"conclusi-n\">Conclusi&#xF3;n</h2>\n<p><em>Curry</em> es una t&#xE9;cnica incre&#xED;blemente &#xFA;til en JavaScript funcional. Te permitir&#xE1;\ngenerar una biblioteca de funciones peque&#xF1;as y f&#xE1;cilmente configuradas que se\ncomportan consistentemente, son r&#xE1;pidas de usar y que se pueden entender al leer\nsu c&#xF3;digo. Agregar <em>curry</em> a tu pr&#xE1;ctica de codificaci&#xF3;n alentar&#xE1; el uso de\nfunciones parcialmente aplicadas a trav&#xE9;s de tu c&#xF3;digo, evitando una gran\ncantidad de repeticiones, y puede ayudarte a obtener mejores h&#xE1;bitos sobre c&#xF3;mo\nnombrar y manejar los argumentos de la funci&#xF3;n.</p>\n<h2 id=\"referencias\">Referencias</h2>\n<ul>\n<li><a href=\"https://www.sitepoint.com/currying-in-functional-javascript/\" target=\"_blank\">A Beginner&#x2019;s Guide to Currying in Functional JavaScript</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\">Function.prototype.bind()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length\" target=\"_blank\">Function.length</a></li>\n<li><a href=\"http://www.cs.nott.ac.uk/~pszgmh/faq.html#currying\" target=\"_blank\">Frequently Asked Questions for comp.lang.functional</a></li>\n<li><div class=\"video-container\"><iframe id=\"ytplayer\" type=\"text/html\" width=\"640\" height=\"360\" frameborder=\"0\" src=\"https://www.youtube.com/embed/iZLP4qOwY8I?autoplay=0\"></iframe></div>\npor Mattias P Johansson</li>\n</ul>\n"
          },
          "06-practice": {
            "title": "Ejercicios de currying",
            "type": "practice",
            "format": "self-paced",
            "duration": 10,
            "exercises": {
              "01-curry-n": {
                "title": "curryN",
                "env": "js",
                "body": "<p>Este es un ejemplo de implementaci&#xF3;n usando <code>curry3</code>, el cual tiene capacidad de\nmanejar hasta tres argumentos:</p>\n<pre><code class=\"lang-js\">function curry3(fun) {\n  return function(one) {\n    return function(two) {\n      return function (three) {\n        return fun(one, two, three)\n      }\n    }\n  }\n}\n</code></pre>\n<p>Si la fuesemos a implementar con la funci&#xF3;n ejemplo:</p>\n<pre><code class=\"lang-js\">function abc(one, two, three) {\n  return one/two/three\n}\n</code></pre>\n<p>Se ver&#xED;a de la siguiente manera:</p>\n<pre><code class=\"lang-js\">var curryC = curry3(abc)\nvar curryB = curryC(6)\nvar curryA = curryB(3)\n\nconsole.log(curryA(2)) // =&gt; 1\n</code></pre>\n<h2 id=\"tarea\">Tarea</h2>\n<p>En este reto, vamos a implementar la funci&#xF3;n &apos;curry&apos; para un n&#xFA;mero arbitrario\nde argumentos.</p>\n<p><code>curryN</code> recibe dos par&#xE1;metros:</p>\n<ul>\n<li>fn: la funci&#xF3;n a la que le queremos a&#xF1;adir <em>curry</em>.</li>\n<li>n: n&#xFA;mero opcional de argumentos para <em>curry</em>. Si no se suministra, entonces\n<code>curryN</code> debe usar la aridad de <code>fn</code> como el valor para <code>n</code>.</li>\n</ul>\n<h2 id=\"ejemplo\">Ejemplo</h2>\n<pre><code class=\"lang-js\">function add3(one, two, three) {\n  return one + two + three\n}\n\nvar curryC = curryN(add3)\nvar curryB = curryC(1)\nvar curryA = curryB(2)\nconsole.log(curryA(3)) // =&gt; 6\nconsole.log(curryA(10)) // =&gt; 13\n\nconsole.log(curryN(add3)(1)(2)(3)) // =&gt; 6\n</code></pre>\n<h2 id=\"condiciones\">Condiciones</h2>\n<ul>\n<li>No usar lazos for/while o <code>Array.prototype.forEach</code>.</li>\n</ul>\n<h2 id=\"pista\">Pista</h2>\n<ul>\n<li>Se puede detectar el n&#xFA;mero esperado de argumentos de una funci&#xF3;n (su aridad)\nrevisando la propiedad .length de la funci&#xF3;n.</li>\n</ul>\n",
                "files": {
                  "Ym9pbGVycGxhdGU=": {
                    "Y3VycnlOLmpz": "function curryN(fn, n) {\n  // La solución vá aquí,\n}\n\nmodule.exports = curryN\n"
                  },
                  "c29sdXRpb24=": {
                    "Y3VycnlOLmpz": "function curryN(fn, n) {\n  n = n || fn.length\n  return function curriedN(arg) {\n    if (n <= 1) return fn(arg)\n    return curryN(fn.bind(this, arg), n - 1)\n  }\n}\n\nmodule.exports = curryN\n"
                  },
                  "dGVzdA==": {
                    "Y3VycnlOLnNwZWMuanM=": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst Submission = require('../solution/curryN');\n\n\ndescribe('curryN()', () => {\n\n  it('debería exportar una función', () => {\n    Assert.equal(typeof Submission, 'function');\n  });\n\n  it('debería crear cadena de funciones hasta haber agotado todos los argumentos', () => {\n    function add3(one, two, three) {\n      return one + two + three;\n    }\n\n    var curryC = Submission(add3);\n    var curryB = curryC(1);\n    var curryA = curryB(2);\n\n    Assert.equal(curryA(3), 6);\n    Assert.equal(curryA(10), 13);\n\n    Assert.equal(Submission(add3)(1)(2)(3), 6);\n  });\n\n  it('no debería usar bucles for/while', () => {\n    const fnBody = Submission.toString();\n    Assert.equal(/(for|while)\\s*\\(/g.test(fnBody), false);\n  });\n\n  it('no debería usar forEach', () => {\n    function add3(one, two, three) {\n      return one + two + three;\n    }\n\n    const spy = Sinon.spy(Array.prototype, 'forEach');\n\n    Assert.equal(Submission(add3)(1)(2)(3), 6);\n    Assert.equal(spy.callCount, 0);\n    spy.restore();\n  });\n\n});\n"
                  }
                }
              }
            }
          },
          "07-quiz": {
            "title": "Cuestionario",
            "type": "quiz",
            "format": "self-paced",
            "duration": 10,
            "questions": [
              {
                "title": "Una función de orden superior es ...",
                "description": "",
                "answers": [
                  "una funci&#xF3;n que retorna otra funci&#xF3;n",
                  "una funci&#xF3;n flecha (arrow function)",
                  "una funci&#xF3;n sin argumentos de entrada ni valor de retorno",
                  "una funci&#xF3;n que recibe otra funci&#xF3;n como argumento"
                ],
                "solution": [
                  0,
                  3
                ]
              },
              {
                "title": "Dada la siguiente función ...",
                "description": "<pre><code class=\"lang-js\">const foo = bar =&gt; baz =&gt; baz.filter(item =&gt; item === bar).shift();\n</code></pre><p>Cu&#xE1;l ser&#xED;a el resultado de invocar <code>foo(&apos;ana&apos;)([&apos;ale&apos;, &apos;mafe&apos;, &apos;ana&apos;])</code>?</p>",
                "answers": [
                  "<code>false</code>",
                  "<code>[&apos;ana&apos;]</code>",
                  "<code>&apos;ana&apos;</code>",
                  "<code>true</code>",
                  "<code>[&apos;ale&apos;, &apos;mafe&apos;]</code>"
                ],
                "solution": [
                  2
                ]
              },
              {
                "title": "Aplicación parcial",
                "description": "<p>Cuando usamos la t&#xE9;cnica de aplicaci&#xF3;n parcial partimos de una funci&#xF3;n que\nrecibe varios argumentos, y creamos una nueva funci&#xF3;n que simplemente invoca a\nla primera pero con un n&#xFA;mero de argumentos ya fijados, para no tener que\nespecificarlos m&#xE1;s tarde. Al aplicar parcialmente...</p>",
                "answers": [
                  "solo podemos aplicar parcialmente un argumento",
                  "fijamos todos los argumentos de una funci&#xF3;n",
                  "fijamos los primeros argumentos (uno o m&#xE1;s)",
                  "fijamos los &#xFA;ltimos argumentos"
                ],
                "solution": [
                  2
                ]
              },
              {
                "title": "Currying",
                "description": "<p>A diferencia de la aplicaci&#xF3;n parcial, cuando aplicamos currying...</p>",
                "answers": [
                  "fijamos todos los argumentos en una sola invocaci&#xF3;n",
                  "fijamos un argumento por funci&#xF3;n",
                  "el compilador hace ejercicio",
                  "hacemos uso de higher order functions"
                ],
                "solution": [
                  1
                ]
              }
            ]
          },
          "08-seminar": {
            "title": "Solucionarios y ejercicios guiados",
            "type": "seminario",
            "format": "guiado",
            "duration": 45,
            "body": "<p>En este seminario revisaremos los ejercicios vistos en esta unidad, lxs\ninstructorxs har&#xE1;n ejercicios guiados y respond&#xE1;n sus preguntas.</p>\n<h2 id=\"requisitos\">Requisitos</h2>\n<ul>\n<li>Haber completado ejercicios de higher order functions, aplicaci&#xF3;n parcial y\ncurrying.</li>\n</ul>\n"
          },
          "09-quiz": {
            "title": "Cuestionario",
            "type": "quiz",
            "format": "self-paced",
            "duration": 10,
            "questions": [
              {
                "title": "Funciones de primera clase",
                "description": "<p>En JavaScript, las funciones son ciudadanas de primera clase, ya que pueden ser\nenviadas como argumento y devueltas como valor de retorno.</p>",
                "answers": [
                  "Verdadero",
                  "Falso"
                ],
                "solution": [
                  0
                ]
              },
              {
                "title": "Currying",
                "description": "<p>Cuando aplicamos currying, partimos de una funci&#xF3;n que recibe varios argumentos\ny la &quot;convertimos&quot; en...</p>",
                "answers": [
                  "un objeto multidimensional",
                  "una secuencia de funciones, cada una esperando un solo argumento",
                  "una funci&#xF3;n pura",
                  "una funci&#xF3;n sin argumentos de entrada"
                ],
                "solution": [
                  1
                ]
              },
              {
                "title": "Funciones como valores de primera clase",
                "description": "<p>En JavaScript, las funciones son valores o ciudadanas de primera y esto permite\nque tengamos higher order functions. Marca todas las caracter&#xED;sticas propias\nde los valores de primera clase:</p>",
                "answers": [
                  "Podemos asignarlas a identificadores (variables)",
                  "No podemos asignarlas a identificadores (variables)",
                  "Podemos asignarlas a propiedades de objetos",
                  "No podemos asignarlas a propiedades de objetos",
                  "Podemos pasarlas como argumentos",
                  "No podemos pasarlas como argumentos",
                  "Podemos usarlas como valor de retorno",
                  "No podemos usarlas como valor de retorno"
                ],
                "solution": [
                  0,
                  2,
                  4,
                  6
                ]
              }
            ]
          },
          "10-closing": {
            "title": "Cierre",
            "type": "seminario",
            "format": "guiado",
            "duration": 15,
            "body": "<h3 id=\"resumen\">Resumen</h3>\n<p>En esta unidad hemos hablado de funciones de orden superior, las cuales son\nfunciones de primera clase que tambi&#xE9;n realizan una o ambas de las siguientes\ntareas:</p>\n<ul>\n<li>Tomar una funci&#xF3;n como argumento</li>\n<li>Devolver una funci&#xF3;n como valor de retorno</li>\n</ul>\n<p>Para ilustrar el pase de una funci&#xF3;n a otra, se dieron algunos ejemplos,\nincluyendo <code>max</code>, <code>finder</code>, <code>best</code>, <code>repeatedly</code>. Muy a menudo, pasar valores a\nfunciones para lograr alg&#xFA;n comportamiento es valioso, pero a veces tal tarea\npuede hacerse m&#xE1;s gen&#xE9;rica al pasar una funci&#xF3;n.</p>\n<p>La cobertura de las funciones que devuelven otras funciones comenz&#xF3; con el\nsiempre valioso <code>always</code>. Una caracter&#xED;stica interesante de <code>always</code> es que\ndevolvi&#xF3; un closure/cierre, una t&#xE9;cnica que ver&#xE1;s una y otra vez en JavaScript.\nAdem&#xE1;s, las funciones que devuelven funciones permiten crear funciones\npotentes.</p>\n<h3 id=\"respondamos-juntxs-las-preguntas-de-la-apertura\">Respondamos juntxs las preguntas de la apertura</h3>\n<ul>\n<li>Qu&#xE9; significa que las funciones son de primera clase en JavaScript?</li>\n<li>Qu&#xE9; es una funci&#xF3;n de orden superior</li>\n<li>Qu&#xE9; es una funci&#xF3;n de primer orden</li>\n<li>Qu&#xE9; es la t&#xE9;cnica de la aplicaci&#xF3;n parcial</li>\n<li>Qu&#xE9; es el <em>currying</em> en programaci&#xF3;n funcional</li>\n</ul>\n<h3 id=\"auto-evaluaci-n\">Auto-evaluaci&#xF3;n</h3>\n<p>Tus instructorxs te compartir&#xE1;n un link al cuestionario de <em>auto evaliaci&#xF3;n</em>.\nEste cuestionario no es calificado.</p>\n"
          }
        }
      },
      "04-workshop": {
        "title": "Hacking: refactoring",
        "bonus": false,
        "description": "<p>La duración estimada de esta unidad es de <em>2h</em>.</p>\n",
        "parts": {
          "00-opening": {
            "title": "Apertura",
            "type": "seminario",
            "format": "guiado",
            "duration": 15
          },
          "01-refactoring": {
            "title": "Implementación por pares",
            "type": "taller",
            "format": "self-paced",
            "duration": 90
          },
          "02-closing": {
            "title": "Cierre",
            "type": "seminario",
            "format": "guiado",
            "duration": 15
          }
        }
      },
      "05-flow-control": {
        "title": "Control de flujo",
        "bonus": false,
        "description": "<p>Como paradigma declarativo, la programación funcional se caracteriza, entre\notras cosas, por expresar &quot;repetición&quot; usando recursión en vez de iteración. En\nesta unidad veremos cómo reemplazar iteración con recursión o higher order\nfunctions, así como las ventajas que ofrece el enfoque funcional para manejar\nasincronía, que es una característica fundamental de JavaScript.</p>\n",
        "parts": {
          "00-opening": {
            "title": "Apertura",
            "type": "seminario",
            "format": "guiado",
            "duration": 15,
            "body": "<h2 id=\"-por-qu-aprender-esto-\">&#xBF;Por qu&#xE9; aprender esto?</h2>\n<p>Como desarrolladora de JavaScript, dominar la recursividad es fundamental para\nresolver ciertos problemas as&#xED; como para visualizar el comportamiento de las\nfunciones. Para ser una buena programadora debes interiorizar la recursi&#xF3;n como\nsegunda naturaleza.</p>\n<p>En la programaci&#xF3;n funcional, que es de estilo declarativo, intentamos evitar\nsentencias imperativas como bucles, usando recursividad como alternativa.</p>\n<h2 id=\"gu-a-de-preguntas-y-conceptos-clave\">Gu&#xED;a de preguntas y conceptos clave</h2>\n<p>La recursividad, as&#xED; como muchos otros conceptos de la programaci&#xF3;n funcional\npueden ser enga&#xF1;osamente simples. La definici&#xF3;n en s&#xED; es corta, pero\nacostumbrarse al concepto e interiorizarlo lleva un tiempo.</p>\n<ul>\n<li>...</li>\n</ul>\n"
          },
          "01-recursion": {
            "title": "Recursividad en JavaScript",
            "type": "lectura",
            "format": "self-paced",
            "duration": 50,
            "body": "<p>La recursividad es uno de los conceptos de programaci&#xF3;n m&#xE1;s simples pero a su\nvez uno de los dif&#xED;ciles de dominar. La definici&#xF3;n te&#xF3;rica para recursividad es:\n&quot;la capacidad de una funci&#xF3;n de invocarse a s&#xED; misma&quot;. Ten en cuenta que la\nrecursi&#xF3;n no es un concepto exclusivo de JavaScript, lo podemos encontrar en\ncasi todos los lenguajes de programaci&#xF3;n.</p>\n<p>A lo largo de esta lecci&#xF3;n veremos que la recursi&#xF3;n es importante para la\nprogramaci&#xF3;n funcional por las siguientes razones:</p>\n<ul>\n<li>Las soluciones recursivas envuelven el uso de abstracciones simples aplicadas\na subconjuntos de un problema com&#xFA;n.</li>\n<li>La recursi&#xF3;n puede ocultar la mutaci&#xF3;n del estado. Recuerda que hablamos sobre\nla mutaci&#xF3;n de estado en las lecciones de <a href=\"../01-pure-functions/README.md\">Funciones\npuras</a> e\n<a href=\"../02-immutability/README.md\">Inmutabilidad</a>.</li>\n<li>La recursi&#xF3;n es una manera de implementar <em>lazyness</em> y estructuras muy largas\no infinitas.</li>\n</ul>\n<h2 id=\"factorial\">Factorial</h2>\n<p>Este es el ejemplo cl&#xE1;sico para entender la recursividad: <strong>factoriales.</strong></p>\n<p>Cuando se calcula el factorial de un n&#xFA;mero <code>n</code> es igual a <code>n</code> multiplicado por\nel para cada entero positivo.</p>\n<pre><code>n! = n * (n - 1) * (n - 2) ... 3 * 2 * 1\nn! = n * [(n - 1) * (n - 2) ... 3 * 2 * 1] = n * (n - 1)!\n</code></pre><p>As&#xED; que el factorial de 5 es igual a <code>5 * 4 * 3 * 2 * 1</code>, lo que nos da como\nresultado 120.</p>\n<pre><code>5! = 5 * 4 * 3 * 2 * 1 = 120\n</code></pre><p>En la programaci&#xF3;n, los factoriales son un ejemplo perfecto de un caso en el que\nse debe utilizar una funci&#xF3;n recursiva. &#xBF;Por qu&#xE9;? Porque estamos haciendo lo\nmismo (multiplicaci&#xF3;n) una y otra vez a un valor particular (un entero positivo)\nhasta que obtenemos el resultado deseado.</p>\n<p>En principo desarrollemos, como ya hemos viniendo haciendo, el caso de prueba:</p>\n<p><strong>factorial.test.js.</strong></p>\n<pre><code class=\"lang-js\">const factorial = require(&apos;./factorial&apos;)\n\ntest(&apos;Should calculate the factorial of the given number&apos;, () =&gt; {\n  expect(factorial(5)).toBe(120)\n})\n</code></pre>\n<p>Una primera implementaci&#xF3;n que cumple caso de pruebas especificado es la\nsiguiente:</p>\n<p><strong>factorial.js.</strong></p>\n<pre><code class=\"lang-js\">const factorial = n =&gt; {\n  if (n === 0) {\n    return 1\n  }\n\n  // &#xA1;Aqu&#xED; est&#xE1; la recursi&#xF3;n!\n  return n * factorial(n - 1)\n}\n\nmodule.exports = factorial\n</code></pre>\n<p>Demostremos que nuestra implementaci&#xF3;n cumple con el caso de prueba:</p>\n<pre><code class=\"lang-sh\">$ yarn run jest -- factorial.test.js\n\nPASS  ./factorial.test.js\n\n  &#x2713; Should calculate the factorial of the given number (3ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        0.638s, estimated 1s\nRan all test suites matching &quot;factorial.test.js&quot;.\nDone in 1.12s.\n</code></pre>\n<h3 id=\"tarea\">Tarea</h3>\n<p>Utiliza la misma funci&#xF3;n <code>factorial()</code> pero en este caso para el entero 10.</p>\n<h2 id=\"caso-base-caso-recursivo\">Caso base, caso recursivo</h2>\n<p>Hay caracter&#xED;sticas claves de la recursi&#xF3;n que deben incluirse en tu c&#xF3;digo para\nque funcione correctamente.</p>\n<p>El primer caso a estudiar es el <strong>caso base</strong>: es s&#xF3;lo una l&#xED;nea de c&#xF3;digo o\nsentencia, normalmente dentro de una cl&#xE1;usula condicional como <code>if</code> que detiene\nla recursi&#xF3;n. Si no se tiene un caso base, la recursi&#xF3;n continuar&#xE1; infinitamente\ny tu programa se bloquear&#xE1; (lo cual no es bueno).</p>\n<p>El segundo es el <strong>caso recursivo</strong>: &#xE9;sta es la afirmaci&#xF3;n donde la recursi&#xF3;n\nrealmente sucede: es donde la funci&#xF3;n recursiva se llama a s&#xED; misma.</p>\n<p>Vamos a explorar ambos casos con m&#xE1;s detalle.</p>\n<p>Mira bien el c&#xF3;digo del ejemplo a continuaci&#xF3;n:</p>\n<p><strong>factorial.js.</strong></p>\n<pre><code class=\"lang-js\">const factorial = n =&gt; {\n  // Este es nuestro caso base - cuando n es igual a 0, se detiene la recursi&#xF3;n\n  // Devolvemos 1 pues es el elemento neutro de la multiplicaci&#xF3;n\n  if (n === 0) {\n    return 1\n  }\n\n  // Este es nuestro caso recursivo\n  // Correr&#xE1; para todas las condiciones de n excepto cuando n es igual a 0\n  return n * factorial(n - 1)\n}\n\nmodule.exports = factorial\n</code></pre>\n<p>&#xBF;crees que tiene l&#xF3;gica?</p>\n<p>Como ejercicio puedes llamar la funci&#xF3;n <code>factorial()</code> usando cualquier n&#xFA;mero\nentero positivo.</p>\n<h2 id=\"condici-n-de-terminaci-n\">Condici&#xF3;n de terminaci&#xF3;n</h2>\n<p>Otra caracter&#xED;stica &#xFA;til (y a menudo necesaria) de una funci&#xF3;n recursiva es la\n<strong>condici&#xF3;n de terminaci&#xF3;n</strong>.</p>\n<p>Esta es una declaraci&#xF3;n espec&#xED;fica que detendr&#xE1; expl&#xED;citamente la recursi&#xF3;n. El\ncaso base es una forma de condici&#xF3;n de terminaci&#xF3;n, aunque para nuestros fines\nusaremos la condici&#xF3;n de terminaci&#xF3;n para describir una sentencia que cancelar&#xE1;\nla recursi&#xF3;n en el caso de una entrada incorrecta u otro error potencial.</p>\n<p>Para poner esto en pr&#xE1;ctica, mira la funci&#xF3;n factorial. &#xBF;Qu&#xE9; pasar&#xED;a si la\nllam&#xE1;ramos usando un entero negativo? Dado que la recursi&#xF3;n s&#xF3;lo se detendr&#xE1;\ncuando n es igual a 0, y eso nunca suceder&#xED;a con un entero negativo, nuestro\nprograma se bloquear&#xED;a.</p>\n<p>Agreguemos un caso de prueba para demostrar lo indicado en el p&#xE1;rrafo anterior:</p>\n<p><strong>factorial.test.js.</strong></p>\n<pre><code class=\"lang-js\">const factorial = require(&apos;./factorial.verbose&apos;)\n\ntest(&apos;Should calculate the factorial of the given number&apos;, () =&gt; {\n  expect(factorial(5)).toBe(120)\n})\n\ntest(&apos;Should not accept negative values&apos;, () =&gt; {\n  expect(() =&gt; {\n    factorial(-1)\n  }).toThrow(&apos;Cannot compute the factorial of a negative integer&apos;)\n})\n</code></pre>\n<p>Si ejecutamos nuestras pruebas obtendremos lo siguiente:</p>\n<pre><code class=\"lang-sh\">$ yarn run jest -- factorial.test.js\n\nFAIL  ./factorial.test.js\n\n  &#x25CF; Should not accept negative values\n\n    RangeError: Maximum call stack size exceeded\n\n      at factorial (factorial.js:1:108)\n      at factorial (factorial.js:9:14)\n      ...\n      at factorial (factorial.js:9:14)\n\n\n  &#x2713; Should calculate the factorial of the given number (3ms)\n  &#x2715; Should not accept negative values (3ms)\n\nTest Suites: 1 failed, 1 total\nTests:       1 failed, 1 passed, 2 total\nSnapshots:   0 total\nTime:        0.685s, estimated 1s\nRan all test suites matching &quot;factorial.test.js&quot;.\n</code></pre>\n<p><strong>&#xA1;Ouch!</strong>, nuestro programa est&#xE1; fallando.</p>\n<p>Para evitar que esto suceda, utilizaremos una condici&#xF3;n de terminaci&#xF3;n para\nasegurarnos que el valor pasado a la funci&#xF3;n sea v&#xE1;lido y no bloquee nuestro\nprograma. Como programadora, debes estar constantemente pensando en c&#xF3;mo estar\npreparada para cualquier tipo de situaci&#xF3;n y asegurarte de que tu c&#xF3;digo puede\nmanejarla correctamente.</p>\n<p><strong>factorial.js.</strong></p>\n<pre><code class=\"lang-js\">const factorial = n =&gt; {\n  if (n &lt; 0) {\n    // Condici&#xF3;n de terminaci&#xF3;n para prevenir recursividad infinita\n    throw new Error(&apos;Cannot compute the factorial of a negative integer&apos;)\n  }\n\n  // Caso base\n  if (n === 0) {\n    return 1\n  }\n\n  // Caso recursivo\n  return n * factorial(n - 1)\n}\n\nmodule.exports = factorial\n</code></pre>\n<p>Ejecutemos ahora nuestras pruebas:</p>\n<pre><code class=\"lang-sh\">$ yarn run jest -- factorial.test.js\n\n PASS  ./factorial.test.js\n\n  &#x2713; Should calculate the factorial of the given number (3ms)\n  &#x2713; Should not accept negative values\n\nTest Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        0.674s, estimated 1s\nRan all test suites matching &quot;factorial.test.js&quot;.\nDone in 1.29s.\n</code></pre>\n<p>Todo parece indicar que la condici&#xF3;n de terminaci&#xF3;n nos ha servido para\nsolventar el error antes presentado.</p>\n<h3 id=\"tarea\">Tarea</h3>\n<p>Puedes intentar describir un nuevo escenario de prueba para ver qu&#xE9; sucede\ncuando se pasa un valor no v&#xE1;lido a la funci&#xF3;n <code>factorial()</code>. Al encontrar una\nfalla, puedes intentar mejorar la implementaci&#xF3;n de la funci&#xF3;n <code>factorial()</code>.</p>\n<h2 id=\"argumentos-en-la-recursi-n\">Argumentos en la recursi&#xF3;n</h2>\n<p>Cuando empieces a construir tu caso recursivo (el c&#xF3;digo que se repetir&#xE1;), una\nde las reglas es asegurarse que los argumentos que utiliza para la recursi&#xF3;n\nllevar&#xE1; a un caso base.</p>\n<p>Si el valor que le pasamos a la llamada de la funci&#xF3;n recursiva es el mismo que\nel valor inicial, es probable que nuestro c&#xF3;digo entre en un bucle infinito, e\ninevitablemente se bloquear&#xE1;.</p>\n<p>Por lo tanto, la pregunta que debes hacerte es: &#xBF;el caso recursivo modifica los\nargumentos de tal manera que cada recursi&#xF3;n lo acerca m&#xE1;s al caso base?</p>\n<p><strong>factorial.js.</strong></p>\n<pre><code class=\"lang-js\">const factorial = n =&gt; {\n  // Condici&#xF3;n de terminaci&#xF3;n para prevenir la recursi&#xF3;n infinita\n  if (n &lt; 0) {\n    throw new Error(&apos;Cannot compute the factorial of a negative integer&apos;)\n  }\n\n  // Caso base\n  if (n === 0) {\n    return 1\n  }\n\n  return n * factorial(n)\n}\n\nfactorial(6)\n</code></pre>\n<ul>\n<li>&#xBF;Qu&#xE9; est&#xE1; mal? &#xBF;Por qu&#xE9; no funciona la recursi&#xF3;n?</li>\n</ul>\n<h3 id=\"tarea\">Tarea</h3>\n<p>Ejecuta el c&#xF3;digo del ejemplo anterior.</p>\n<p>Hmm&#x2026;&#x200B; algo est&#xE1; mal.</p>\n<p>Observa atentamente la &#xFA;ltima l&#xED;nea de definici&#xF3;n de la funci&#xF3;n factorial y\nc&#xE1;mbiala para que el factorial funcione correctamente.</p>\n<p>Utiliza los casos de pruebas antes mostrados para ver que todo funcione\ncorrectamente.</p>\n<h2 id=\"ahora-es-tu-turno\">Ahora es tu turno</h2>\n<p>Ahora que hemos cubierto lo esencial, trata de reconstruir la funci&#xF3;n\n<code>factorial()</code> en la que hemos estado trabajando, pero esta vez escr&#xED;belo todo\ndesde cero. Para ayudarte, aqu&#xED; hay cinco preguntas que puedes utilizar siempre\nque vayas a incluir la recursi&#xF3;n en tu c&#xF3;digo:</p>\n<ul>\n<li>&#xBF;Cu&#xE1;les son los casos b&#xE1;sicos?</li>\n<li>&#xBF;Cu&#xE1;l es el caso recursivo?, &#xBF;hay m&#xE1;s de un caso recursivo?</li>\n<li>&#xBF;He incluido alguna otra condici&#xF3;n de terminaci&#xF3;n necesaria?</li>\n<li>&#xBF;Las declaraciones de la funci&#xF3;n conducen al caso base?</li>\n<li>&#xBF;Se construye la recursi&#xF3;n en el caso base hasta que el resultado deseado es\ndevuelto por la funci&#xF3;n?</li>\n</ul>\n<h3 id=\"plantilla\">Plantilla</h3>\n<p>Define el caso base. Dado que un factorial significa multiplicar un entero por\ncada entero entre &#xE9;l mismo y uno, el caso base es uno.</p>\n<p>Define el caso recursivo. &#xBF;Qu&#xE9; acciones deben realizarse una y otra vez para\nlograr el resultado deseado?</p>\n<p>Escribe cualquier condici&#xF3;n de terminaci&#xF3;n para evitar que la funci&#xF3;n acepte\nargumentos que puedan dar error.</p>\n<p><strong>factorial.js.</strong></p>\n<pre><code class=\"lang-js\">const factorial = n =&gt; {\n  // Aqu&#xED; va tu c&#xF3;digo.\n}\n</code></pre>\n<p>Llegados a este punto, imagina por un momento que completaste la tarea y\ncompartiste tus resultados con tus amigas, una compa&#xF1;era mientras hacia revisi&#xF3;n\nde t&#xFA; c&#xF3;digo encontr&#xF3; un comportamiento extra&#xF1;o, su caso de prueba fue el\nsiguiente:</p>\n<pre><code class=\"lang-sh\">&gt; factorial(32768)\nRangeError: Maximum call stack size exceeded\n</code></pre>\n<p>Por si no lo recuerdas, este error ya lo hab&#xED;amos visto antes, cuando intentamos\ncalcular el <code>factorial(-1)</code> y no ten&#xED;amos la <strong>condici&#xF3;n de terminaci&#xF3;n</strong>\napropiada.</p>\n<p>Ahora bien, para poder resolver este problema, primero debemos dejar claro un\nconcepto que no hab&#xED;amos explicado anteriormente, definamos entonces qu&#xE9; es la\npila de llamadas o <em>Call Stack</em>.</p>\n<h2 id=\"pila-de-llamadas-call-stack-\">Pila de llamadas (Call Stack)</h2>\n<p>Ser&#xED;a &#xFA;til examinar m&#xE1;s de cerca la forma en que se maneja el control a trav&#xE9;s\nde las funciones. Aqu&#xED; est&#xE1; un programa simple que hace algunas llamadas a\nfunciones:</p>\n<p><strong>greet.</strong></p>\n<pre><code class=\"lang-js\">function greet(who) {\n  console.log(&quot;Hello &quot; + who)\n}\ngreet(&quot;Harry&quot;)\nconsole.log(&quot;Bye&quot;)\n</code></pre>\n<ul>\n<li>La llamada a <code>greet</code> hace que el control salte al inicio de esa funci&#xF3;n (l&#xED;nea\n2).</li>\n<li>Se hace una llamada a <code>console.log</code> (una funci&#xF3;n predeterminada del\nnavegador), esta funci&#xF3;n toma el control, hace su trabajo, devuelve el control\na la l&#xED;nea 2.</li>\n<li>Entonces llega al final de la funci&#xF3;n <code>greet</code>, as&#xED; que el control se vuelve al\nlugar de la llamada, en la l&#xED;nea 4.</li>\n<li>La l&#xED;nea siguiente llama a <code>console.log</code> de nuevo (l&#xED;nea 5).</li>\n</ul>\n<p>Veamos otra representaci&#xF3;n de lo mencionado previamente, mostraremos un esquema\nde c&#xF3;mo fluye el control en la funci&#xF3;n:</p>\n<pre><code>top\n    greet\n        console.log\n    greet\ntop\n    console.log\ntop\n</code></pre><p>Como la funci&#xF3;n debe saltar de nuevo al lugar de la llamada original cuando\nllega la final de la funci&#xF3;n, la computadora debe recordar el contexto o entorno\ndesde el cual se hizo la llamada a la funci&#xF3;n. Por ejemplo en un caso,\n<code>console.log</code> tiene que volver a saltar a la funci&#xF3;n <code>greet</code>. En otro caso, debe\nsaltar al final del programa.</p>\n<p>El lugar donde la computadora almacena este contexto es la pila de llamadas o\n<em>call stack</em>. Cada vez que se hace una llamada a una funci&#xF3;n, el contexto actual\nse pone encima de esta pila de llamadas. Cuando la funci&#xF3;n se devuelve, elimina\nel contexto superior de la pila y lo utiliza para continuar con la ejecuci&#xF3;n de\nla funci&#xF3;n.</p>\n<p>El almacenamiento de esta pila requiere espacio en la memoria de la computadora.\nCuando la pila crece demasiado, la computadora fallar&#xE1; y mostrar&#xE1; un mensaje\ncomo &quot;No hay espacio en la pila&quot; o &quot;Hay demasiada recursi&#xF3;n&quot;. El c&#xF3;digo\nsiguiente ilustra esto haciendo una pregunta realmente dif&#xED;cil a la computadora,\nesto causa llamadas infinitas hacia adelante y hacia atr&#xE1;s entre dos funciones.\nComo la computadora no tiene una pila infinita, se queda sin espacio, y sucede\nque &quot;explotamos la pila&quot;.</p>\n<pre><code class=\"lang-js\">function chicken() {\n  return egg()\n}\nfunction egg() {\n  return chicken()\n}\nconsole.log(chicken() + &quot; came first.&quot;)\n// &#x2192; ??\n</code></pre>\n<p>Esto es precisamente lo que est&#xE1; pasando con nuestra funci&#xF3;n <code>factorial</code>, a\npartir de ciertos enteros positivos nuestra pila de llamadas crece demasido y\nobtenemos el error: <em>Maximum call stack size exceeded</em>. Veamos entonces si\npodemos solventar dicho error.</p>\n<h2 id=\"tail-call-optimization\">Tail-call Optimization</h2>\n<p>La optimizaci&#xF3;n de llamadas de cola o <em>tail-call optimization</em> es una\ncaracter&#xED;stica del compilador que reemplaza las invocaciones de funciones\nrecursivas con una estructura de control o bucle. La eliminaci&#xF3;n de las\ninvocaciones de funciones elimina tanto el tama&#xF1;o de la pila como el tiempo\nnecesario para configurar los marcos de la pila de funciones. Tanto el tiempo\ncomo el espacio se guardan.</p>\n<p>La programadora debe escribir m&#xE9;todos de una manera que facilite la optimizaci&#xF3;n\nde llamadas de cola. Esto significa que la &#xFA;ltima funci&#xF3;n invocada debe ser la\ninvocaci&#xF3;n de la funci&#xF3;n recursiva. Si revisamos con detenimiento nuestra\nfunci&#xF3;n <code>factorial</code> podremos apreciar que nuestra llamada recursiva es como\nsigue:</p>\n<pre><code class=\"lang-js\">return n * factorial(n - 1)\n</code></pre>\n<p>Cabe preguntarnos si <strong>la &#xFA;ltima funci&#xF3;n invocada debe ser la funci&#xF3;n recursiva</strong>,\nen nuestra implementaci&#xF3;n actual en realidad es la multiplicaci&#xF3;n\nlo que se invoca de &#xFA;ltimo. Sin embargo, podemos mejorar la implementaci&#xF3;n tal\ncomo sigue:</p>\n<p><strong>factorial.js.</strong></p>\n<pre><code class=\"lang-js\">&apos;use strict&apos;\nconst factorial = (n, acc = 1) =&gt; {\n  if (n &lt; 0) {\n    // Condici&#xF3;n de terminaci&#xF3;n para prevenir recursividad infinita\n    throw new Error(&apos;Cannot compute the factorial of a negative integer&apos;)\n  }\n\n  // Caso base\n  if (n === 0) {\n    return acc\n  }\n\n  // Caso recursivo\n  return factorial(n - 1, n * acc)\n}\n\nmodule.exports = factorial\n</code></pre>\n<p>Esta implementaci&#xF3;n del <code>factorial</code> ahora si hace <em>tail-call recursion</em> y por\nende est&#xE1; optimizada, nota que la &#xFA;ltima funci&#xF3;n llamada es <code>factorial</code> y no la\nmultiplicaci&#xF3;n (caso previo). De este modo, el compilador es capaz de invocar\n<code>factorial</code> en un bucle hasta que se devuelva un resultado distinto a este en la\nrepetici&#xF3;n.</p>\n<p>Nota que hemos agregado un par&#xE1;metro adicional a <code>factorial</code> este parametro es\n<code>acc</code>. Este es el acumulador, <code>acc</code> es el valor de funci&#xF3;n acumulado hasta este\npunto. Hagamos una simulaci&#xF3;n escrita del m&#xE9;todo recurrente para ver c&#xF3;mo se\nacumula el resultado factorial:</p>\n<pre><code>factorial(5)\nfactorial(5, 1)\nfactorial(4, 5)\nfactorial(3, 20)\nfactorial(2, 60)\nfactorial(1, 120)\nfactorial(0, 120)\n120\n</code></pre><p>Todas las funciones recursivas deben tener un caso base que termine la\nrecursi&#xF3;n. Anteriormente el caso base para la funci&#xF3;n <code>factorial</code> es cuando n =\n0, en cuyo caso se devuelve 1. Con esta nueva implementaci&#xF3;n, el caso base de\n<code>factorial</code> es tambi&#xE9;n cuando n = 0, pero en lugar de retornar 1, se devuelve el\nvalor acumulado o <code>acc</code>.</p>\n<h3 id=\"tarea\">Tarea</h3>\n<p>Nuestra nueva implementaci&#xF3;n de <code>factorial</code> igualmente tiene un problema, si\nbien hacemos uso de una caracter&#xED;stica de ES2015, la cual es la definici&#xF3;n de\nparam&#xE9;tros por omisi&#xF3;n de una funci&#xF3;n, un usuario podr&#xED;a invocar nuestra nueva\nfunci&#xF3;n <code>factorial</code> de la siguiente manera: <code>factorial(5, 2)</code>, &#xBF;qu&#xE9; crees que\npasar&#xED;a en dicho caso?, trata de hacer una simulaci&#xF3;n escrita antes de ejecutar\nc&#xF3;digo, &#xBF;el resultado es correcto?</p>\n<p>Un modo de corregir la nueva implementaci&#xF3;n es siguiendo la siguientes consejos:</p>\n<h3 id=\"estrategia-para-la-optimizaci-n-de-llamadas-de-cola\">Estrategia para la optimizaci&#xF3;n de llamadas de cola</h3>\n<p>Utiliza esta estrategia para crear funciones recursivas optimizadas:</p>\n<ul>\n<li>Crear una funci&#xF3;n recursiva interna que tenga un par&#xE1;metro acumulador\nadicional</li>\n<li>El caso base de la funci&#xF3;n recursiva interna ser&#xE1; devolver el acumulador</li>\n<li>La invocaci&#xF3;n recursiva proporciona un valor actualizado para el acumulador</li>\n<li>La funci&#xF3;n externa delega a la funci&#xF3;n recursiva interna usando los valores\niniciales apropiados</li>\n</ul>\n<p>Sigue estas estrategias y tus funciones recursivas ser&#xE1;n &#xF3;ptimas, proporcionando\nmejoras significativas en el rendimiento.</p>\n<blockquote>\n<p><strong>Nota</strong></p>\n<p>Si t&#xFA; c&#xF3;digo fuese a producci&#xF3;n con este implementaci&#xF3;n, se utilizar&#xED;an otras\nt&#xE9;cnicas como\n<a href=\"http://benalman.com/news/2010/11/immediately-invoked-function-expression/\" target=\"_blank\">IIFEs</a>\nentre otras para encapsular y prevenir la creaci&#xF3;n de un nuevo <em>closure</em> cada\nvez que llamamos a <code>factorial</code>.</p>\n</blockquote>\n<p>Si probamos la funci&#xF3;n <code>factorial</code> haciendo uso de <em>tail-call optimization</em> con\nn&#xFA;meros enteros positivos peque&#xF1;os observamos que todo funciona de igual manera,\npero, en esta ocasi&#xF3;n debemos actualizar nuestro caso de pruebas para incluir el\nejemplo que nos dio nuestra amiga:</p>\n<p><strong>factorial.test.js.</strong></p>\n<pre><code class=\"lang-js\">const factorial = require(&apos;./factorial.tail&apos;)\n\ntest(&apos;Should calculate the factorial of the given number&apos;, () =&gt; {\n  expect(factorial(5)).toBe(120)\n})\n\ntest(&apos;Should not accept negative values&apos;, () =&gt; {\n  expect(() =&gt; {\n    factorial(-1)\n  }).toThrow(&apos;Cannot compute the factorial of a negative integer&apos;)\n})\n\ntest(&apos;Should avoid too much recursion&apos;, () =&gt; {\n  expect(() =&gt; {\n    factorial(32768)\n  }).not.toThrowError(/stack size exceeded/)\n})\n</code></pre>\n<p>Si ejecutamos nuestras pruebas obtendremos un resultado similar al siguiente:</p>\n<pre><code class=\"lang-sh\">$ yarn run jest -- factorial.test.js\n\n FAIL  ./factorial.tail.test.js\n  &#x25CF; Should avoid too much recursion\n\n    expect(function).not.toThrowError(regexp)\n\n    Expected the function not to throw an error matching:\n      /stack size exceeded/\n    Instead, it threw:\n      RangeError: Maximum call stack size exceeded\n\n  &#x2713; Should calculate the factorial of the given number (5ms)\n  &#x2713; Should not accept negative values (1ms)\n  &#x2715; Should avoid too much recursion (10ms)\n\nTest Suites: 1 failed, 1 total\nTests:       1 failed, 2 passed, 3 total\nSnapshots:   0 total\nTime:        0.656s, estimated 1s\nRan all test suites matching &quot;factorial.test.js&quot;.\n</code></pre>\n<p><strong>(o_O)</strong> &#xA1;Un momento!, &#xBF;qu&#xE9; ha pasado?, &#xBF;por qu&#xE9; sigue fallando?.</p>\n<p>Pues resulta que es importante mencionar que esto funcionar&#xE1; si tu sistema\nproporciona optimizaciones de llamadas de cola. Ya que JavaScript no lo hace en\nla mayor&#xED;a de sus implementaciones, tal como se indica\n<a href=\"https://babeljs.io/learn-es2015/#ecmascript-2015-features-tail-calls\" target=\"_blank\">ac&#xE1;</a></p>\n<blockquote>\n<p><strong>Nota</strong></p>\n<p>Al momento de la publicaci&#xF3;n de esta lecci&#xF3;n, la &#xFA;nica implementaci&#xF3;n de\nJavaScript conocida por el autor que soporta tail-call optimization es\n<a href=\"https://github.com/Kinoma/kinomajs\" target=\"_blank\">KinomaJS</a>, la cual ofrece un <em>runtime</em>\noptimizado para el desarrollo de aplicaciones que funcionen en dispositivos IoT\ny ofrecen compatibilidad con ES6, de hecho,\n<a href=\"http://kinoma.com/develop/documentation/js6/\" target=\"_blank\">ac&#xE1;</a> puedes ver los resultados\nde sus pruebas.</p>\n<p>Si bien no es necesario para los objetivos de este curso, puedes intentar\ndescargar el c&#xF3;digo de KinomaJS pues es <em>Open Source</em>, construirla y correr la\n<em>suite</em> de pruebas que ofrecen y corroborar por tu cuenta.</p>\n</blockquote>\n<p>Ahora que sabemos que la mayor&#xED;a de las implementaciones de JavaScript no\nimplementan todav&#xED;a la <em>tail-call optimization</em> es necesario ver si existen\notras alternativas con las cuales podamos solventar el error antes visto.</p>\n<h2 id=\"trampolining\">Trampolining</h2>\n<p>&#xBF;C&#xF3;mo podemos optimizar las funciones de JavaScript recursivas sin la\noptimizaci&#xF3;n de llamadas de cola? Una opci&#xF3;n es volver a escribir su funci&#xF3;n\nrecursiva en forma de bucle.</p>\n<p>Funci&#xF3;n factorial escrita usando estructura de datos de control:</p>\n<pre><code class=\"lang-js\">const factorial = n =&gt; {\n  let acc = 1\n  for (let i = n; i &gt; 0; i--) {\n    acc *= i\n  }\n  return acc\n}\n</code></pre>\n<p>As&#xED; se implementa la optimizaci&#xF3;n de llamadas de cola manualmente. La desventaja\nes la p&#xE9;rdida de elegancia y la expresividad de la implementaci&#xF3;n recursiva.</p>\n<p>Otra opci&#xF3;n es usar un trampol&#xED;n.</p>\n<p>Las trampolines son ubicaciones de memoria que mantienen direcciones apuntando a\nrutinas de servicio de interrupci&#xF3;n, como por ejemplo rutinas de E/S. Al correr\nel c&#xF3;digo la ejecuci&#xF3;n salta al trampol&#xED;n y luego salta inmediatamente hacia\nafuera, o rebota, de ah&#xED; el t&#xE9;rmino trampol&#xED;n.</p>\n<p>Un solo trampol&#xED;n es suficiente para expresar todas las transferencias de\ncontrol de un programa; Un programa expresado de esta manera podemos decir que\nest&#xE1; escrito al estilo trampol&#xED;n. Las funciones de trampol&#xED;n se pueden utilizar\npara implementar llamadas de funci&#xF3;n recursivas de cola en lenguajes de\nprogramaci&#xF3;n orientados al uso de pilas.</p>\n<p>Pero es m&#xE1;s f&#xE1;cil de lo que parece en la teor&#xED;a, como veremos a continuaci&#xF3;n.</p>\n<h3 id=\"un-simple-trampol-n\">Un simple trampol&#xED;n</h3>\n<p>Veamos una implementaci&#xF3;n simple de trampol&#xED;n:</p>\n<pre><code class=\"lang-js\">const trampoline = f =&gt; {\n  while (f &amp;&amp; f instanceof Function) {\n    f = f.apply(f.context, f.args)\n  }\n  return f\n}\n</code></pre>\n<p>El trampol&#xED;n toma una funci&#xF3;n y ejecuta repetidamente el valor de retorno hasta\nque se devuelve un resultado distinto al de una funci&#xF3;n. Uno se siente tentado a\nusar el trampol&#xED;n de la siguiente manera:</p>\n<pre><code class=\"lang-js\">const factorial = (n) =&gt; {\n  const recur = (n, acc) =&gt; n ? recur(n - 1, n * acc) : acc\n\n  return trampoline(recur(n, 1));\n}\n</code></pre>\n<p>Pero esto no produce la optimizaci&#xF3;n deseada. &#xBF;Por qu&#xE9;? Supongamos que se invoca\nla funci&#xF3;n factorial con n = 5. &#xBF;Qu&#xE9; valor se le pasa al trampol&#xED;n?</p>\n<pre><code class=\"lang-js\">recur(5, 1)\n</code></pre>\n<p>Es una expresi&#xF3;n de funci&#xF3;n que devuelve el valor 120. El trampol&#xED;n se invoca\ncon el valor 120. Esto es esencialmente la misma aplicaci&#xF3;n de la llamada de\ncola optimizada del factorial, excepto que la optimizaci&#xF3;n de la llamada de la\ncola no est&#xE1; disponible en el entorno de JavaScript. &#xBF;Qu&#xE9; sali&#xF3; mal?</p>\n<p>Ten&#xED;amos la intenci&#xF3;n de invocar un trampol&#xED;n con una funci&#xF3;n de referencia, no\ncon un resultado de la funci&#xF3;n. Mientras que lo siguiente funciona</p>\n<pre><code class=\"lang-js\">return trampoline(Function() { recur(n, 1) })\n</code></pre>\n<p>Es dif&#xED;cil de manejar. Necesitamos un medio para obtener una referencia a la\ninvocaci&#xF3;n de la funci&#xF3;n, completa con todos los par&#xE1;metros, por lo que podemos\ninvocar la funci&#xF3;n en un momento posterior. Aunque no estaba destinado para este\nprop&#xF3;sito, la funci&#xF3;n <em>Function.bind</em> se ajusta bien a nuestra intenci&#xF3;n, y por\nlo tanto, mejora nuestra implementaci&#xF3;n de Factorial:</p>\n<p>Mejor pero no del todo &#xF3;ptima</p>\n<pre><code class=\"lang-js\">const factorial = n =&gt; {\n  const recur = (n, acc) =&gt; n ? recur(n - 1, n * acc) : acc\n\n  return trampoline(recur.bind(null, n, 1))\n}\n</code></pre>\n<p>Ahora invocamos el trampol&#xED;n con la expresi&#xF3;n:</p>\n<pre><code class=\"lang-js\">recur.bind(null, n, 1))\n</code></pre>\n<p>La funci&#xF3;n <em>bind</em> es una funci&#xF3;n que cuando se invoca devuelve el valor de la\nfunci&#xF3;n que est&#xE1; haciendo la llamada, en este caso <em>recur</em>, utilizando el\ncontexto de llamada especificado (el puntero <em>this</em>, que en este caso es nulo,\nya que no llamamos a nuestra funci&#xF3;n dentro de una instancia del objeto), Y la\nlista de par&#xE1;metros. El resultado de <em>recur (n, 1)</em> se devuelve cuando se invoca\nla funci&#xF3;n <em>bind</em>. &#xA1;Esto es exactamente lo que pretend&#xED;amos pasar al trampol&#xED;n,\nuna funci&#xF3;n!</p>\n<p>Sin embargo, esta implementaci&#xF3;n a&#xFA;n no est&#xE1; optimizada. Para ver esto\nsupongamos que invocamos <em>factorial</em> con el valor n = 5. Cuando el trampol&#xED;n\ninvoca la funci&#xF3;n <em>bind</em> devolviendo la invocaci&#xF3;n de <em>recur(5, 1)</em> &#xBF;qu&#xE9;\nresultado se devuelve? No es una funci&#xF3;n, sino que es el resultado de la\nrecurrencia (4, 5), que es 120. S&#xF3;lo tenemos un rebote.</p>\n<p>Esto se arregla f&#xE1;cilmente:</p>\n<p>Implementaci&#xF3;n optimizada de factorial:</p>\n<pre><code class=\"lang-js\">const factorial = n =&gt; {\n  const recur = (n, acc) =&gt; n ? recur.bind(null, n - 1, n * acc) : acc\n\n  return trampoline(recur.bind(null, n, 1));\n}\n</code></pre>\n<p>Ahora el trampol&#xED;n proporcionar&#xE1; el efecto deseado y continuar&#xE1; haciendo un\nbucle hasta que vuelva a devolver el valor acumulado.</p>\n<p><strong>factorial.js.</strong></p>\n<pre><code class=\"lang-js\">&apos;use strict&apos;\n\nconst isFunction = require(&apos;lodash.isfunction&apos;)\n\nconst trampoline = (fn, ...args) =&gt; {\n  let result = fn.apply(fn, args)\n\n  while (isFunction(result)) {\n    result = result()\n  }\n\n  return result\n}\n\nconst factorial = n =&gt; {\n  if (n &lt; 0) {\n    throw new Error(&apos;Cannot compute the factorial of a negative integer&apos;)\n  }\n\n  const fun = (n, acc = 1) =&gt; {\n    return n ? () =&gt; fun(n - 1, n * acc) : acc\n  }\n\n  return trampoline(fun(n))\n}\n\nmodule.exports = factorial\n</code></pre>\n<p>Tras este ultimo cambio ejecutemos nuestras pruebas.</p>\n<pre><code class=\"lang-sh\">$ yarn run jest -- factorial.test.js\n\n PASS  ./factorial.safe.test.js\n  &#x2713; Should calculate the factorial of the given number (3ms)\n  &#x2713; Should not accept negative values (1ms)\n  &#x2713; Should avoid too much recursion (7ms)\n\nTest Suites: 1 passed, 1 total\nTests:       3 passed, 3 total\nSnapshots:   0 total\nTime:        0.648s, estimated 1s\nRan all test suites matching &quot;factorial.test.js&quot;.\nDone in 1.15s.\n</code></pre>\n<p>Con esto ya hemos evitado saturar el <em>stack</em>. Sin embargo, el resultado es el\nsiguiente:</p>\n<pre><code class=\"lang-sh\">&gt; factorial(32768)\nInfinity\n</code></pre>\n<blockquote>\n<p><strong>(o_O) Advertencia</strong></p>\n<p>Este error se debe a otra limitaci&#xF3;n en JavaScript, esta vez relacionada con el\nmanejo de enteros largos. Si bien la reparaci&#xF3;n de este &#xFA;ltimo <em>bug</em> est&#xE1; fuera\ndel alcance de la lecci&#xF3;n actual, igual se mostrar&#xE1; su resoluci&#xF3;n para\ncompletar el recorrido.</p>\n<p>Esta limitaci&#xF3;n puede ser arreglada haciendo uso de\n<a href=\"https://github.com/peterolson/BigInteger.js\" target=\"_blank\">BigInteger.js</a>. Ejecutemos\nentonces</p>\n<pre><code class=\"lang-sh\">yarn add --dev big-integer\n</code></pre>\n<p>y ajustemos de nuevo nuestra implementaci&#xF3;n.</p>\n</blockquote>\n<p><strong>factorial.js.</strong></p>\n<pre><code class=\"lang-js\">&apos;use strict&apos;\n\nconst isFunction = require(&apos;lodash.isfunction&apos;)\nconst bigInt = require(&apos;big-integer&apos;)\n\nconst trampoline = (fn, ...args) =&gt; {\n  let result = fn.apply(fn, args)\n\n  while (isFunction(result)) {\n    result = result()\n  }\n\n  return result\n}\n\nconst factorial = n =&gt; {\n  if (n &lt; 0) {\n    throw new Error(&apos;Cannot compute the factorial of a negative integer&apos;)\n  }\n\n  const fun = (n, acc = bigInt.one) =&gt; {\n    return n.greater(0) ? () =&gt; fun(n.minus(1), acc.multiply(n)) : acc\n  }\n\n  return trampoline(fun(bigInt(n)))\n}\n\nmodule.exports = factorial\n</code></pre>\n<p>Ahora podremos obtener una representaci&#xF3;n que nos funciona para n&#xFA;meros grandes:</p>\n<pre><code class=\"lang-sh\">&gt; factorial(5)\n{ [Number: 120] value: 120, sign: false, isSmall: true }\n&gt; factorial(5) == 120\ntrue\n&gt; factorial(180)\n{ [Number: Infinity]\n  value:\n    [ 0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      9603200,\n      3198603,\n      3278187,\n      2302693,\n      9233864,\n      7538181,\n      4141796,\n      3001782,\n      1142564,\n      4664891,\n      6331964,\n      5603584,\n      809209,\n      5744504,\n      8568581,\n      5064353,\n      1980647,\n      6535588,\n      972945,\n      3196673,\n      6095985,\n      1495273,\n      3218633,\n      6710321,\n      7399609,\n      9410103,\n      7356315,\n      2097309,\n      8013811,\n      9809411,\n      953395,\n      6004486,\n      4353351,\n      7777940,\n      4079886,\n      9175403,\n      8466838,\n      5133689,\n      2996569,\n      2499134,\n      89606,\n      2 ],\n  sign: false,\n  isSmall: false }\n</code></pre>\n<p>Y dichos n&#xFA;meros grandes (<code>isSmall: false</code>) los podemos transformar a cadenas de\ncaracteres de la siguiente manera:</p>\n<pre><code class=\"lang-sh\">&gt; fact(180).toString()\n&apos;200896062499134299656951336898466838917540340798867777940435335160044860953395980941180138112097309735631594101037399609671032132186331495273609598531966730972945653558819806475064353856858157445040809209560358463319644664891114256430017824141796753818192338642302693327818731986039603200000000000000000000000000000000000000000000&apos;\n</code></pre>\n<h2 id=\"otros-ejercicios-que-puedes-hacer\">Otros ejercicios que puedes hacer</h2>\n<ul>\n<li>Implementa la funci&#xF3;n <code>myLength</code>, la cual toma un <em>array</em> como entrada y\nretorna la longitud de dicho <em>array</em> o n&#xFA;mero de elementos. Ejemplo:\n<code>myLength([1, 2, 3]) = 3</code></li>\n<li>Crea una funci&#xF3;n <code>cycle</code> que toma un n&#xFA;mero entero positivo y un <em>array</em> como\nargumentos y crea un nuevo <em>array</em> que contendr&#xE1; los elementos del <em>array</em> de\nentrada multiplicados tantas veces como indica el n&#xFA;mero entero positivo\npasado como primer argumento. Ejemplo: <code>cycle(2, [1, 2, 3]) = [1, 2, 3, 1, 2,\n3]</code></li>\n</ul>\n<h2 id=\"referencias\">Referencias</h2>\n<ul>\n<li><a href=\"https://www.codecademy.com/en/courses/javascript-lesson-205\" target=\"_blank\">Recursion in JavaScript</a>\npor Code Academy</li>\n<li><a href=\"http://eloquentjavascript.net/03_functions.html#h_D2Yui+mx6D\" target=\"_blank\">The Call Stack</a>\nde Marijn Haverbeke</li>\n<li><a href=\"http://shop.oreilly.com/product/0636920028857.do\" target=\"_blank\">Functional Javascript</a> de\nMichael Fogus</li>\n<li><a href=\"https://taylodl.wordpress.com/2013/06/07/functional-javascript-tail-call-optimization-and-trampolines/\" target=\"_blank\">Functional JavaScript &#x2013; Tail Call Optimization and Trampolines</a></li>\n<li><a href=\"http://raganwald.com/2013/03/28/trampolines-in-javascript.html\" target=\"_blank\">Trampolines in JavaScript</a></li>\n</ul>\n"
          },
          "02-practice": {
            "title": "Ejercicios de recursividad",
            "type": "practice",
            "format": "self-paced",
            "duration": 10,
            "exercises": {
              "03-get-deps": {
                "title": "getDependencies",
                "env": "js",
                "body": "<h2 id=\"tarea\">Tarea</h2>\n<p>Implementar una funci&#xF3;n recursiva que devuelva todas las dependencias &#xFA;nicas y\nsubdependencias de un m&#xF3;dulo ordenadas alfab&#xE9;ticamente. Las dependencias deben\nimprimirse como dependencia@versi&#xF3;n, p. &apos;Inflection@1.2.6&apos;.</p>\n<p>Se permiten m&#xFA;ltiples versiones del mismo m&#xF3;dulo, pero los m&#xF3;dulos duplicados de\nla misma versi&#xF3;n deben eliminarse</p>\n<h2 id=\"argumentos\">Argumentos</h2>\n<ul>\n<li>tree: un &#xE1;rbol de dependencias. Vea a continuaci&#xF3;n un ejemplo de la estructura.</li>\n</ul>\n<h2 id=\"ejemplo\">Ejemplo</h2>\n<pre><code class=\"lang-js\">var loremIpsum = {\n  &quot;name&quot;: &quot;lorem-ipsum&quot;,\n  &quot;version&quot;: &quot;0.1.1&quot;,\n  &quot;dependencies&quot;: {\n    &quot;optimist&quot;: {\n      &quot;version&quot;: &quot;0.3.7&quot;,\n      &quot;dependencies&quot;: {\n        &quot;wordwrap&quot;: {\n          &quot;version&quot;: &quot;0.0.2&quot;\n        }\n      }\n    },\n    &quot;inflection&quot;: {\n      &quot;version&quot;: &quot;1.2.6&quot;\n    }\n  }\n}\n\ngetDependencies(loremIpsum)\n// =&gt; [&apos;inflection@1.2.6&apos;, &apos;optimist@0.3.7&apos;, &apos;wordwrap@0.0.2&apos;]\n</code></pre>\n<h2 id=\"condiciones\">Condiciones</h2>\n<ul>\n<li>No usar ninguna estructura enlazada como for/while.</li>\n</ul>\n<h2 id=\"plantilla\">Plantilla</h2>\n<pre><code class=\"lang-js\">\nfunction getDependencies(tree) {\n  // LA SOLUCI&#xF3;N VA AQU&#xED;\n  // Nota: sea libre de agregar argumentos adicionales\n  // a esta funci&#xF3;n para usarla con llamadas recursivas.\n  // o no! Hay muchas maneras de hacer funcionar la recursividad.\n}\n\nmodule.exports = getDependencies\n</code></pre>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" target=\"_blank\">Object.keys</a></li>\n</ul>\n",
                "files": {
                  "c29sdXRpb24=": {
                    "Z2V0RGVwZW5kZW5jaWVzLmpz": "function getDependencies(mod, result) {\n  result = result || []\n  var dependencies = mod && mod.dependencies || []\n  Object.keys(dependencies).forEach(function(dep) {\n    var key = dep + '@' + mod.dependencies[dep].version\n    if (result.indexOf(key) === -1) result.push(key)\n    getDependencies(mod.dependencies[dep], result)\n  })\n  return result.sort()\n}\n\nmodule.exports = getDependencies\n"
                  }
                }
              },
              "02-reduce": {
                "title": "reduce",
                "env": "js",
                "body": "<p>La recursi&#xF3;n es un concepto fundamental en programaci&#xF3;n, que nos puede llevar a\nsoluciones elegantes y eficientes a problemas algor&#xED;tmicos. De hecho, la\nrecursi&#xF3;n es tan poderosa, que toda l&#xF3;gica iterativa puede ser expresada usando\nfunciones recursivas. A la hora de iterar estructuras de datos anidadas, la\nrecursi&#xF3;n se convierte en una herramienta indispensable.</p>\n<p>Una funci&#xF3;n recursiva es una funci&#xF3;n que se llama a s&#xED; misma. Por ejemplo, esta\nfunci&#xF3;n recursiva recibe un Array de palabras, y retorna un arreglo con las\nmismas palabras, pero todas en may&#xFA;sculas.</p>\n<pre><code class=\"lang-js\">function toUpperArray(items) {\n  if (!items.length) return []             // caso base\n  var head = items[0]                      // elemento sobre el que operar\n  head = head.toUpperCase()                // llevamos a cabo operaci&#xF3;n\n  var tail = items.slice(1)                // siguiente\n  return [head].concat(toUpperArray(tail)) // recursi&#xF3;n\n}\n\ntoUpperArray([&apos;hello&apos;, &apos;world&apos;]) // =&gt; [&apos;HELLO&apos;, &apos;WORLD&apos;]\n</code></pre>\n<p>El objetivo de este ejercicio es que te familiarices con la recursi&#xF3;n a trav&#xE9;s\nde la implementaci&#xF3;n de una interfaz conocida usando una funci&#xF3;n recursiva.</p>\n<h2 id=\"tarea\">Tarea</h2>\n<p>Implementa <code>Array#reduce</code> usando recursi&#xF3;n.</p>\n<p>Para comprobar que tu implementaci&#xF3;n funciona correctamente, la usaremos para\nejecutar la soluci&#xF3;n del ejercicio anterior de <code>basic_reduce</code>. Tu funci&#xF3;n\n<code>reduce</code> recibir&#xE1; un arreglo de palabras, una funci&#xF3;n, y un valor inicial que\nreturnar&#xE1; un objeto con la cuenta de apariciones de cada palabra.</p>\n<p>Por simplicidad, tu implementaci&#xF3;n de <code>reduce</code> <strong>no necesita imitar el\ncomportamiento de un reduce sin valor inicial</strong>. Puedes asumir que el valor\nsiempre se incluye en la invocaci&#xF3;n.</p>\n<h2 id=\"argumentos\">Argumentos</h2>\n<ul>\n<li>arr: El Array que queremos reducir</li>\n<li>fn: Function para usar en cada paso de la reducci&#xF3;n. Igual que <code>Array#reduce</code>,\nesta funci&#xF3;n debe recibir <code>previousValue</code>, <code>currentValue</code>, <code>index</code> y el\n<code>array</code> sobre el que estamos iterando.</li>\n<li>init: Valor inicial de la reducci&#xF3;n. A diferencia de <code>Array#reduce</code>, este\nvalor es obligatorio (puedes asumir que siempre se incluye).</li>\n</ul>\n<h2 id=\"ejemplo\">Ejemplo</h2>\n<pre><code class=\"lang-js\">// Tu funci&#xF3;n `reduce` debe comportarse como `Array.reduce`, pero recibir&#xE1; el\n// arreglo sobre el que operar como primer argumento:\n\nreduce([1,2,3], function(prev, curr, index, arr) {\n  return prev + curr\n}, 0)\n// =&gt; 6\n</code></pre>\n<h2 id=\"requisitos\">Requisitos</h2>\n<ul>\n<li>No uses bucles <code>for/while</code> ni <code>Array#forEach</code>.</li>\n<li>No uses m&#xE9;todos de <code>Array</code> como <code>Array#map</code> o <code>Array.reduce</code>.</li>\n</ul>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Recursion\" target=\"_blank\">Wikipedia - Recursion</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\" target=\"_blank\">MDN - Array.reduce</a></li>\n</ul>\n<h2 id=\"boilerplate\">Boilerplate</h2>\n<pre><code class=\"lang-js\">function reduce(arr, fn, initial) {\n  // TU SOLUCI&#xD3;N AQU&#xCD;\n}\n\nmodule.exports = reduce\n</code></pre>\n",
                "files": {
                  "c29sdXRpb24=": {
                    "cmVkdWNlLmpz": "function reduce(arr, fn, initial) {\n  return (function reduceOne(index, value) {\n    if (index > arr.length - 1) return value // end condition\n    return reduceOne(index + 1, fn(value, arr[index], index, arr)) // calculate & pass values to next step\n  })(0, initial) // IIFE. kick off recursion with initial values\n}\n\nmodule.exports = reduce\n"
                  }
                }
              },
              "01-discount": {
                "title": "Reemplaza iteración con recursión",
                "env": "js",
                "body": "<h2 id=\"tarea\">Tarea</h2>\n<p>Refactoriza la funci&#xF3;n <code>applyDiscount()</code> reemplazando iteraci&#xF3;n con recursi&#xF3;n y\naseg&#xFA;rate de que no tenga efectos secundarios.</p>\n<pre><code class=\"lang-js\">// Broken: mutates array as well as objects!!\nconst applyDiscount = (cart, discount) =&gt; {\n  for (let i = 0; i &lt; cart.length; i++) {\n    cart[i].price *= (1 - discount);\n  }\n  return cart;\n};\n\nmodule.exports = applyDiscount;\n</code></pre>\n<h2 id=\"ejemplo\">Ejemplo</h2>\n<p>Ejemplo de uso de la funci&#xF3;n:</p>\n<pre><code class=\"lang-js\">const myCart = [\n  { price: 1 },\n  { price: 2 },\n  { price: 3 }\n];\n\nconst cartWithDiscount = applyDiscount(myCart, .3);\nconsole.log(myCart, cartWithDiscount);\n</code></pre>\n",
                "files": {
                  "c29sdXRpb24=": {
                    "c29sdXRpb24uanM=": "const discount = .2;\n\n// Broken: mutates array as well as objects!!\nconst applyDiscount = cart => {\n  for (let i = 0; i < cart.length; i++) {\n    cart[i].price *= (1 - discount);\n  }\n  return cart;\n};\n\nconst myCart = [\n  { price: 1 },\n  { price: 2 },\n  { price: 3 }\n];\n\nconst cartWithDiscount = applyDiscount(myCart, .3);\nconsole.log(myCart, cartWithDiscount);\n"
                  }
                }
              }
            }
          },
          "03-async": {
            "title": "Asincronía en JavaScript",
            "type": "lectura",
            "format": "self-paced",
            "duration": 30,
            "body": "<p>En JavaScript a menudo necesitamos lidiar con el comportamiento asincr&#xF3;nico,\nque puede ser confuso para los programadores que s&#xF3;lo tienen experiencia con\nc&#xF3;digo s&#xED;ncrono. A continuaci&#xF3;n se explicar&#xE1; qu&#xE9; es c&#xF3;digo as&#xED;ncrono, algunas de\nlas dificultades de usar c&#xF3;digo as&#xED;ncrono, y maneras de manejar estas\ndificultades.</p>\n<h2 id=\"-cu-l-es-la-diferencia-entre-c-digo-s-ncrono-y-as-ncrono-\">&#xBF;Cu&#xE1;l es la diferencia entre c&#xF3;digo s&#xED;ncrono y as&#xED;ncrono?</h2>\n<h2 id=\"c-digo-s-ncrono\">C&#xF3;digo s&#xED;ncrono</h2>\n<p>En los programas s&#xED;ncronos, si tienes dos l&#xED;neas de c&#xF3;digo (L1 seguida de L2),\nentonces L2 no puede comenzar a ejecutarse hasta que L1 haya terminado de\nejecutarse.</p>\n<p>Puedes imaginar que estuvieses en una fila de gente que espera para comprar\nboletos de tren. No puedes comenzar a comprar un boleto de tren hasta que todas\nlas personas delante de t&#xED; hayan terminado de comprar sus boletos. Del mismo\nmodo, la gente detr&#xE1;s de t&#xED; no puede comenzar a comprar sus boletos hasta que\nhayan comprado el suyo.</p>\n<h2 id=\"c-digo-as-ncrono\">C&#xF3;digo as&#xED;ncrono</h2>\n<p>En los programas as&#xED;ncronos, se pueden tener dos l&#xED;neas de c&#xF3;digo (L1 seguido\npor L2), donde L1 programa alguna tarea que se ejecutar&#xE1; en el futuro, pero L2\nse ejecuta antes de que se complete esa tarea programada por L1.</p>\n<p>Imagina que est&#xE1;s sentada comiendo en un restaurante. Otras personas ordenan su\ncomida. T&#xFA; Tambi&#xE9;n puedes pedir tu comida. No tienes que esperar a que las\notras personas reciban su comida y terminen de comer antes de que tomen tu\norden. Del mismo modo, otras personas no tienen que esperar para obtener su\ncomida y terminar de comer antes de que puedas ordenar tu comida. Todo el mundo\nobtendr&#xE1; su comida tan pronto como en el restaurant hayan terminado de cocinar.</p>\n<p>La secuencia en la que las personas reciben sus alimentos a menudo se\ncorrelaciona con la secuencia en la que ordenaron el alimento, pero estas\nsecuencias no siempre tienen que ser id&#xE9;nticas. Por ejemplo, si tu pides un\nbistec, y luego yo pido un vaso de agua, probablemente recibir&#xE9; mi pedido\nprimero, ya que normalmente no toma tanto tiempo servir un vaso de agua en\ncomparaci&#xF3;n con preparar y servir un filete.</p>\n<p>Ten en cuenta que as&#xED;ncrono no significa lo mismo que concurrente o multihilo.\nJavaScript puede tener c&#xF3;digo as&#xED;ncrono, pero generalmente es de subproceso\n&#xFA;nico. Esto es como si un restaurante con un solo trabajador hiciera todas las\ntareas. Si este trabajador hace sus oficios lo suficientemente r&#xE1;pido y cambia\nentre las tareas de forma eficiente, entonces el restaurante aparentemente\ntendr&#xED;a m&#xFA;ltiples trabajadores.</p>\n<h2 id=\"ejemplos\">Ejemplos</h2>\n<p>La funci&#xF3;n <code>setTimeout</code> es probablemente la manera m&#xE1;s sencilla de programar de\nforma as&#xED;ncrona el c&#xF3;digo para que se ejecute en el futuro:</p>\n<pre><code class=\"lang-js\">// Diga &quot;Hola.&quot;\nconsole.log(&quot;Hola.&quot;)\n// Diga &quot;Adi&#xF3;s&quot; en dos segundos contando desde este momento.\nsetTimeout(() =&gt; {\n  console.log(&quot;&#xA1;Adi&#xF3;s!&quot;)\n}, 2000)\n // Decir  &quot;Hola de nuevo&quot;\nconsole.log(&quot;&#xA1;Hola de nuevo!&quot;)\n</code></pre>\n<p>Si s&#xF3;lo est&#xE1; familiarizado con el c&#xF3;digo s&#xED;ncrono, puede esperar que el c&#xF3;digo\nanterior se comporte de la siguiente manera:</p>\n<pre><code class=\"lang-text\">Diga &#x201C;Hola&quot;.\nNo haga nada durante dos segundos.\nDiga &#xA1;Adi&#xF3;s!&quot;\nDiga &quot;&#xA1;Hola de nuevo!&quot;\n</code></pre>\n<p>Pero <code>setTimeout</code> no interrumpe la ejecuci&#xF3;n del c&#xF3;digo. S&#xF3;lo programa algo que\nsuceda en el futuro, y luego sigue inmediatamente a la siguiente l&#xED;nea.</p>\n<pre><code class=\"lang-sh\">Diga &#x201C;Hola&quot;.\nDiga &quot;&#xA1;Hola de nuevo!&quot;\nNo haga nada durante dos segundos.\nDiga &#xA1;Adi&#xF3;s!&quot;\n</code></pre>\n<h2 id=\"obtener-datos-de-solicitudes-ajax\">Obtener datos de solicitudes AJAX</h2>\n<p>La confusi&#xF3;n entre el comportamiento del c&#xF3;digo s&#xED;ncrono y el c&#xF3;digo as&#xED;ncrono\nes un problema com&#xFA;n para los personas que est&#xE1;n aprendiendo a programar y que\nest&#xE1;n lidiando con el tema de las solicitudes AJAX en JavaScript. A menudo\nescriben c&#xF3;digo jQuery que se parece a algo como esto:</p>\n<pre><code class=\"lang-js\">const getData = () =&gt; {\n  let data\n  $.get(&quot;/api/example&quot;, response =&gt; {\n    data = response\n  })\n\n  return data\n}\nconst data = getData()\nconsole.log(`La data es: ${data}`)\n</code></pre>\n<p>Este c&#xF3;digo no se comporta como t&#xFA; esperar&#xED;as desde el punto de vista s&#xED;ncrono.\nAl igual que <code>setTimeout</code> en el ejemplo anterior, <code>$.get</code> no pausa la ejecuci&#xF3;n\ndel c&#xF3;digo, s&#xF3;lo programa alg&#xFA;n c&#xF3;digo para ejecutarse una vez que el servidor\nretorna una respuesta. Eso significa que la linea <code>return data</code> se ejecutar&#xE1;\nantes que <code>data = response</code>, por lo que el c&#xF3;digo anterior siempre imprimir&#xE1;\n<code>La data es: _undefined_</code>.</p>\n<p>El c&#xF3;digo as&#xED;ncrono necesita ser estructurado de una manera diferente que el\nc&#xF3;digo s&#xED;ncrono, y la forma m&#xE1;s b&#xE1;sica de hacerlo es con las funciones de\ndevoluci&#xF3;n de llamada, m&#xE1;s comunmente conocidas como <em>callbacks</em> (en ingl&#xE9;s).</p>\n<h2 id=\"_callbacks_\"><em>Callbacks</em></h2>\n<p>Supongamos que llamas a una amiga y le pides alguna informaci&#xF3;n, por ejemplo,\nla direcci&#xF3;n postal de un amigo mutuo que has perdido. Tu amiga no tiene esta\ninformaci&#xF3;n memorizada, por lo que tiene que buscarla en su libreta de\ndirecciones. Esto podr&#xED;a llevarle unos minutos. Existen diferentes estrategias\npara proceder:</p>\n<ul>\n<li><em>S&#xED;ncrono:</em> T&#xFA; permaneces en la l&#xED;nea telef&#xF3;nica con ella y esperas mientras\nella mira su libreta.</li>\n<li><em>As&#xED;ncrono:</em> Le dices a tu amiga que te devuelva la llamada una vez que tenga\nla informaci&#xF3;n. Mientras tanto, tu puedes concentrar toda tu atenci&#xF3;n en\notras tareas que necesitas hacer, como por ejemplo dise&#xF1;ar un algoritmo.</li>\n</ul>\n<p>En JavaScript, podemos crear funciones as&#xED;ncronas que reciben otras funciones\ncomo argumentos, que se llamar&#xE1;n una vez que la tarea se haya completado.</p>\n<pre><code class=\"lang-js\">const data = getData()\nconsole.log(&quot;The data is: &quot; + data)\n\nLe pasaremos una funcion _callback_ a `getData`:\n\ngetData(data =&gt; {\n  console.log(`The data is: ${data}`)\n})\n</code></pre>\n<p>Por supuesto, &#xBF;c&#xF3;mo sabe <code>getData</code> que estamos pasando una funci&#xF3;n? &#xBF;C&#xF3;mo se\nllama y c&#xF3;mo se carga el par&#xE1;metro <code>data</code>? En este momento, nada de esto est&#xE1;\nsucediendo; Tenemos que cambiar la funci&#xF3;n <code>getData</code>, as&#xED; que sabr&#xE1; que una\nfunci&#xF3;n de respuesta de llamada es su par&#xE1;metro.</p>\n<pre><code class=\"lang-js\">const getData = callback =&gt; {\n  $.get(&quot;/api/example&quot;, response =&gt; {\n    callback(response)\n  })\n}\n</code></pre>\n<p>Notar&#xE1;s que ya est&#xE1;bamos pasando una funci&#xF3;n de respuesta de llamada o\n<em>callback</em> a <code>$.get</code>, tal vez sin darnos cuenta de lo que era. Tambi&#xE9;n pasamos\nuna respuesta de llamada a la funci&#xF3;n <code>setTimeout(callback, delay)</code> en el\nprimer ejemplo.</p>\n<p>Dado que <code>$.get</code> ya acepta una respuesta de llamada, no necesitamos crear\nmanualmente otro en <code>getData</code>, podemos pasar directamente la respuesta de\nllamada que nos dieron:</p>\n<pre><code class=\"lang-js\">const getData = callback =&gt; {\n $.get(&quot;/api/example&quot;, callback)\n}\n</code></pre>\n<p>Las funciones de respuesta de llamada se usan con mucha frecuencia en\n<em>JavaScript</em> y, si has pasado alg&#xFA;n tiempo escribiendo c&#xF3;digo en <em>JavaScript</em>,\nes muy probable que las hayas utilizado. Casi todas las aplicaciones web har&#xE1;n\nuso de respuestas de llamada a trav&#xE9;s de eventos (por ejemplo,\n<code>window.onclick</code>), <code>setTimeout</code> y <code>setInterval</code>, o solicitudes AJAX.</p>\n<h2 id=\"problemas-comunes-del-c-digo-as-ncrono\">Problemas comunes del c&#xF3;digo as&#xED;ncrono</h2>\n<h3 id=\"puede-resultar-confuso-al-principio\">Puede resultar confuso al principio</h3>\n<p>Algunas personas deciden que tratar con c&#xF3;digo as&#xED;ncrono es demasiado\ncomplicado para trabajar, por lo que intentan hacer que todo sea sincr&#xF3;nico.\nPor ejemplo, en lugar de usar <code>setTimeout</code>, podr&#xED;a crear una funci&#xF3;n s&#xED;ncrona\npara no hacer nada durante un per&#xED;odo de tiempo determinado:</p>\n<pre><code class=\"lang-js\">const pause = duration =&gt; {\n  const start = new Date().getTime()\n  while(new Date().getTime() - start &lt; duration) {}\n}\n</code></pre>\n<p>Del mismo modo, al realizar una llamada <em>AJAX</em>, es posible establecer una opci&#xF3;n\npara que la llamada sea s&#xED;ncrona en lugar de as&#xED;ncrona (aunque esta opci&#xF3;n\npierde lentamente el soporte del navegador). Tambi&#xE9;n hay alternativas s&#xED;ncronas\na muchas funciones as&#xED;ncronas en Node.js.</p>\n<p>Tratar de evitar c&#xF3;digo as&#xED;ncrono y reemplazarlo con c&#xF3;digo s&#xED;ncrono es casi\nsiempre una mala idea  porque <em>JavaScript</em> s&#xF3;lo tiene un solo hilo (excepto\ncuando se utiliza <em>Web Workers</em>). Esto significa que la p&#xE1;gina web no responder&#xE1;\nmientras se ejecuta el <em>script</em>. Si utilizas la funci&#xF3;n sincr&#xF3;nica <code>pause</code> o una\nllamada <em>AJAX</em> s&#xED;ncrona, el usuario no podr&#xE1; hacer nada mientras est&#xE9;n en\nejecuci&#xF3;n.</p>\n<p>El problema es a&#xFA;n peor cuando se utiliza <em>JavaScript</em> en el servidor: el\nservidor no podr&#xE1; responder a ninguna solicitud mientras espera que se\ncompleten las funciones s&#xED;ncronas, lo que significa que cada usuario que haga\nuna solicitud al servidor tendr&#xE1; que esperar para obtener una respuesta.</p>\n<h3 id=\"problemas-de-alcance-con-_callbacks_-dentro-de-lazos\">Problemas de alcance con <em>callbacks</em> dentro de lazos</h3>\n<p>Cuando se crea una devoluci&#xF3;n de llamada o <em>callback</em> dentro de un bucle <code>for</code>,\npuedes encontrarte con alg&#xFA;n comportamiento inesperado. Piensa en lo que\nesperar&#xED;as que el c&#xF3;digo escrito a continuaci&#xF3;n hiciera, y luego intenta\nejecutarlo en la consola <em>JavaScript</em> de tu navegador.</p>\n<pre><code class=\"lang-js\">for(var i = 1; i &lt;= 3; i++) {\n  setTimeout(() =&gt; {\n    console.log(i + &quot; second(s) elapsed&quot;)\n  }, i * 1000)\n}\n</code></pre>\n<p>Es probable que el c&#xF3;digo anterior est&#xE1; dise&#xF1;ado con la intenci&#xF3;n mostrar los\nmensajes siguientes, con un segundo de retardo entre cada mensaje:</p>\n<pre><code class=\"lang-console\">1 second(s) elapsed.\n2 second(s) elapsed.\n3 second(s) elapsed.\n</code></pre>\n<p>Pero el resultado que realmente muestra es el siguiente:</p>\n<pre><code class=\"lang-console\">4 second(s) elapsed.\n4 second(s) elapsed.\n4 second(s) elapsed.\n</code></pre>\n<p>El problema es que <code>console.log (i + &quot;second (s) elapsed&quot;)</code> est&#xE1; en la\ndevoluci&#xF3;n de llamada de una funci&#xF3;n as&#xED;ncrona. En el momento en que se\nejecuta, el bucle <code>for</code> se habr&#xE1; terminado y la variable <code>i</code> ser&#xE1; igual a 4.</p>\n<p>Hay varias soluciones a este problema, pero la m&#xE1;s com&#xFA;n es envolver la llamada\na <code>setTimeout</code> en un <em>closure</em>, lo que crear&#xE1; un nuevo &#xE1;mbito con una <code>i</code>\ndiferente en cada iteraci&#xF3;n:</p>\n<pre><code class=\"lang-js\">for(var i = 1; i &lt;= 3; i++) {\n  (i =&gt; {\n    setTimeout(() =&gt; {\n      console.log(i + &quot; second(s) elapsed&quot;)\n    }, i * 1000)\n  })(i)\n}\n</code></pre>\n<p>Pero como estamos utilizando ECMAScript 2015, entonces una soluci&#xF3;n\nm&#xE1;s elegante es usar <code>let</code> en lugar de <code>var</code>, ya que permite crear un nuevo\n&#xE1;mbito para <code>i</code> en cada iteraci&#xF3;n:</p>\n<pre><code class=\"lang-js\">for(let i = 1; i &lt;= 3; i++) {\n  setTimeout(() =&gt; {\n    console.log(i + &quot; second(s) elapsed&quot;)\n  }, i * 1000)\n}\n</code></pre>\n<h3 id=\"infierno-de-_callback_\">Infierno de <em>callback</em></h3>\n<p>A veces se tiene una serie de tareas en las que cada paso depende de los\nresultados del paso anterior. Esto es  muy sencillo de tratar usando c&#xF3;digo\ns&#xED;ncrono:</p>\n<pre><code class=\"lang-js\">const text = readFile(fileName)\nconst tokens = tokenize(text)\nconst parseTree = parse(tokens)\nconst optimizedTree = optimize(parseTree)\nconst output = evaluate(optimizedTree)\n\nconsole.log(output);\n</code></pre>\n<p>Cuando intentas hacer eso usando c&#xF3;digo as&#xED;ncrono, es f&#xE1;cil caer en el llamado\ninfierno de <em>callback</em>, que es un problema com&#xFA;n en el que se termina con\nfunciones <em>callback</em> profundamente anidadas unas dentro de otras. Son\nparticularmente susceptibles a este fen&#xF3;meno el c&#xF3;digo Node.js y las\naplicaciones de <em>front-end</em> con un mont&#xF3;n de llamadas AJAX. Podr&#xED;an terminar\nvi&#xE9;ndose as&#xED;:</p>\n<pre><code class=\"lang-js\">readFile(fileName, text =&gt; {\n  tokenize(text, tokens =&gt; {\n    parse(tokens, parseTree =&gt; {\n      optimize(parseTree, optimizedTree =&gt; {\n        evaluate(optimizedTree, output =&gt; {\n          console.log(output)\n        })\n      })\n    })\n  })\n})\n</code></pre>\n<p>Este tipo de c&#xF3;digo es dif&#xED;cil de leer y puede ser un verdadero dolor de cabeza\ncada vez que se necesite hacer cambios. Si tiene devoluciones de llamada\nprofundamente anidadas como esta, normalmente es una buena idea organizar el\nc&#xF3;digo de forma diferente. Existen varias estrategias diferentes para\nrefactorizar devoluciones de llamada profundamente anidadas.</p>\n<h4 id=\"divide-el-c-digo-en-distintas-funciones-con-nombres-apropiados\">Divide el c&#xF3;digo en distintas funciones con nombres apropiados</h4>\n<p>Le puedes dar nombres a las funciones de devoluci&#xF3;n de llamada para que puedas\nhacer referencia a ellas por nombre. Esto ayuda a que el c&#xF3;digo sea m&#xE1;s\nsuperficial, y tambi&#xE9;n divide el c&#xF3;digo de manera natural en peque&#xF1;as secciones\nl&#xF3;gicas.</p>\n<pre><code class=\"lang-js\">const readFinish = text =&gt; {\n  tokenize(text, tokenizeFinish)\n}\nconst tokenizeFinish = tokens =&gt; {\n  parse(tokens, parseFinish)\n}\nconst parseFinish = parseTree =&gt; {\n  optimize(parseTree, optimizeFinish)\n}\nconst optimizeFinish = optimizedTree =&gt; {\n  evalutate(optimizedTree, evaluateFinish)\n}\nconst evaluateFinish = output =&gt; {\n  console.log(output)\n}\nreadFile(fileName, readFinish)\n</code></pre>\n<h4 id=\"crear-una-funci-n-para-ejecutar-una-serie-de-tareas\">Crear una funci&#xF3;n para ejecutar una serie de tareas</h4>\n<p>Esta soluci&#xF3;n no es tan flexible como la anterior, pero si se tiene una tuber&#xED;a\nde tareas compuesta de funciones as&#xED;ncronas, se puede crear una funci&#xF3;n de\nutilidad que tome una matriz de tareas y las ejecute una tras otra.</p>\n<pre><code class=\"lang-js\">const performTasks = (input, tasks) =&gt; {\n  if (tasks.length === 1) {\n    return tasks[0](input)\n  }\n\n  tasks[0](input, output =&gt; {\n    performTasks(output, tasks.slice(1)) // Ejecuta las tareas en el arreglo &apos;tasks[]&apos;\n  })\n}\n\nperformTasks(fileName,\n  [readFile, token, parse, optimize, evaluate, output =&gt; {\n  console.log(output)\n}])\n</code></pre>\n<h2 id=\"herramientas-para-el-manejo-de-c-digo-as-ncrono\">Herramientas para el manejo de c&#xF3;digo as&#xED;ncrono</h2>\n<h3 id=\"bibliotecas-async\">Bibliotecas Async</h3>\n<p>Si est&#xE1;s utilizando un mont&#xF3;n de funciones as&#xED;ncronas, puede valer la pena\nutilizar una biblioteca de funciones as&#xED;ncronas, en lugar de tener que crear\ntus propias funciones de utilidad. Async.js es una biblioteca popular que tiene\nmuchas herramientas &#xFA;tiles para tratar el c&#xF3;digo as&#xED;ncrono.</p>\n<h3 id=\"promises\">Promises</h3>\n<p>Las promesas o <em>promises</em> son una forma popular de deshacerse del infierno de\n<em>callback</em>. Originalmente se trataba de un tipo de constructo introducido por\nbibliotecas <em>JavaScript</em> como <code>Q</code> y <code>when.js</code>, pero estos tipos de bibliotecas\nse volvieron lo suficientemente populares como para que <em>promises</em> se\nproporcionan de forma nativa en ECMAScript 2015.</p>\n<p>La idea es que en lugar de usar funciones que acepten una  entrada y un\n<em>callback</em>, hacemos una funci&#xF3;n que devuelve un objeto <em>promises</em>, es decir, un\nobjeto que representa un valor que est&#xE1; destinado a existir en el futuro.</p>\n<p>Por ejemplo, supongamos que comenzamos con una funci&#xF3;n <code>getData</code> que hace una\nsolicitud AJAX y usa un <em>callback</em> de la manera habitual:</p>\n<pre><code class=\"lang-js\">const getData = (options, callback) =&gt; {\n  $.get(&quot;/api/example&quot;, options, response =&gt; {\n    callback(null, JSON.parse(response))\n  }, () =&gt; {\n    callback(new Error(&quot;AJAX request failed!&quot;))\n  })\n}\n// uso\ngetData({name: &quot;John&quot;}, (err, data) =&gt; {\n  if (err) {\n    console.log(`Error! ${err}`)\n  } else {\n  console.log(data)\n  }\n})\n</code></pre>\n<p>Podemos cambiar la funci&#xF3;n <code>getData</code> para que devuelva un <em>promise</em>. Podemos\ncrear un objeto <em>promise</em> con la nueva funcion Promise (callback), donde\ncallback es una funci&#xF3;n con dos argumentos: <code>resolve</code> y <code>reject</code>. Llamaremos a\n<code>resolve</code> si conseguimos obtener los datos. Si algo sale mal, llamaremos a\n<code>reject</code>.</p>\n<p>Una vez que tenemos una funci&#xF3;n que devuelve un objeto <em>promise</em>, podemos usar\nel m&#xE9;todo <code>.then</code> en este objeto para especificar lo que debe suceder una vez\nque se llama a <code>resolve</code> o <code>reject</code>.</p>\n<pre><code class=\"lang-js\">const getData = options =&gt;\n  new Promise((resolve, reject) =&gt; { // crear un nuevo objeto promise\n    $.get(&quot;/api/example&quot;, options, response =&gt; {\n      resolve(JSON.parse(response)) // en caso que todo salga como planeamos\n    }, () =&gt; {\n      reject(new Error(&quot;AJAX request failed!&quot;)) // en caso que algo salga mal\n    })\n  })\n\n// uso\ngetData({name: &quot;John&quot;}).then(data =&gt; {\n  console.log(data)\n}, err =&gt; {\n  console.log(&quot;Error! &quot; + err)\n}\n</code></pre>\n<p>El manejo de errores parece mejor, pero es dif&#xED;cil ver c&#xF3;mo estamos haciendo\nlas cosas de manera mas conveniente dado el tama&#xF1;o de la funci&#xF3;n. La ventaja es\nm&#xE1;s clara cuando reescribimos nuestro ejemplo de infierno <em>callback</em> usando\n<em>promises</em>:</p>\n<pre><code class=\"lang-js\">readFile(&quot;fileName&quot;)\n.then(text =&gt; tokenize(text))\n.then(tokens =&gt; parse(tokens))\n.then(parseTree =&gt; optimize(parseTree))\n.then(optimizedTree =&gt; evaluate(optimizedTree))\n.then(output =&gt; {\n  console.log(output)\n})\n</code></pre>\n<h2 id=\"conclusi-n\">Conclusi&#xF3;n</h2>\n<p>A este punto, ya deber&#xED;as estar familiarizada con las estrategias para hacer\nfrente a algunas de las dificultades que surgen cuando se utiliza c&#xF3;digo\nas&#xED;ncrono.</p>\n<h2 id=\"referencias\">Referencias</h2>\n<ul>\n<li><a href=\"https://www.pluralsight.com/guides/front-end-javascript/introduction-to-asynchronous-javascript\" target=\"_blank\">Introduction to asynchronous JavaScript</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval\" target=\"_blank\">WindowOrWorkerGlobalScope.setInterval()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout\" target=\"_blank\">WindowOrWorkerGlobalScope.setTimeout()</a></li>\n<li><a href=\"http://caolan.github.io/async/\" target=\"_blank\">Async</a></li>\n<li><a href=\"https://github.com/kriskowal/q\" target=\"_blank\">Q</a></li>\n<li><a href=\"https://github.com/cujojs/when\" target=\"_blank\">when.js</a></li>\n</ul>\n"
          },
          "04-practice": {
            "title": "Ejercicios de asincronía",
            "type": "practice",
            "format": "self-paced",
            "duration": 10,
            "exercises": {
              "01-load-users": {
                "title": "loadUsers",
                "env": "js",
                "body": "<p>&#xA1;Este c&#xF3;digo est&#xE1; da&#xF1;ado!</p>\n<p>Un desarrollador que trabaja en Java ha hecho <em>commit</em> de este terrible c&#xF3;digo a\nnuestro repositorio y, &#xA1;no lo prob&#xF3;!</p>\n<pre><code class=\"lang-js\">function loadUsers(userIds, load, done) {\n  var users = []\n  for (var i = 0; i &lt; userIds.length; i++) {\n    users.push(load(userIds[i]))\n  }\n  return users\n}\n\nmodule.exports = loadUsers\n</code></pre>\n<h2 id=\"tarea\">Tarea</h2>\n<p>&#xA1;Arregla este c&#xF3;digo! La funci&#xF3;n <em>callback</em> deber&#xED;a ser llamada con todos los\nusuarios ya cargados. El orden de los usuarios deber&#xED;a coincidir con el orden de\nlos ID de usuarios suministrados. Porque esta funci&#xF3;n es as&#xED;ncrona, no nos\nimporta el valor que retorna.</p>\n<h2 id=\"argumentos\">Argumentos</h2>\n<ul>\n<li>userIds: un arreglo num&#xE9;rico de ID de usuarios.</li>\n<li>load: una funci&#xF3;n usada para cargar los objetos usuario. La funci&#xF3;n espera un\nID num&#xE9;rico y una llamada <em>callback</em>. La llamada <em>callback</em> se invoca con el\nresultado de cargar los usuarios con el ID especificado (un objeto ID de\nusuario o devuelve una respuesta nula <em>null</em>).</li>\n<li>done: una funci&#xF3;n que espera un arreglo con objetos usuario (como fue\nrecuperado desde <code>load</code>).</li>\n</ul>\n<h2 id=\"condiciones\">Condiciones</h2>\n<ul>\n<li>No usar lazos for/while  (usar <em>Array#forEach</em> est&#xE1; bien).</li>\n<li>El orden de los resultados en <code>done</code> debe ser los mismos que fueron\nespecificados en <code>userIds</code>.</li>\n<li>Los usuarios deben ser cargados en paralelo, por ejemplo el tiempo  total de\nla tarea no debe tomar m&#xE1;s de un segundo.</li>\n<li>No crear ninguna funci&#xF3;n innecesaria como por ejemplo <em>helpers</em>.</li>\n</ul>\n<h2 id=\"pistas\">Pistas</h2>\n<ul>\n<li>No se necesita usar <em>sort</em> para mantener el orden.</li>\n<li>Usar <code>console.log</code> va afectar la verificaci&#xF3;n. Solo se usa <code>console.log</code>\ncuando se use <code>functional-javascript run</code>.</li>\n</ul>\n<h2 id=\"plantilla\">Plantilla</h2>\n<pre><code class=\"lang-js\">function loadUsers(userIds, load, done) {\n  var users = []\n  for (var i = 0; i &lt; userIds.length; i++) {\n    users.push(load(userIds[i]))\n  }\n  return users\n}\n\nmodule.exports = loadUsers\n</code></pre>\n",
                "files": {
                  "c29sdXRpb24=": {
                    "bG9hZFVzZXJzLmpz": "function loadUsers(userIds, load, done) {\n  var completed = 0\n  var users = []\n  userIds.forEach(function(id, index) {\n    load(id, function(user) {\n      users[index] = user\n      if (++completed === userIds.length) return done(users)\n    })\n  })\n}\n\nmodule.exports = loadUsers\n"
                  }
                }
              }
            }
          },
          "05-quiz": {
            "title": "Cuestionario",
            "type": "quiz",
            "format": "self-paced",
            "duration": 10,
            "questions": []
          },
          "06-seminar": {
            "title": "Solucionarios y ejercicios guiados",
            "type": "seminario",
            "format": "guiado",
            "duration": 45,
            "body": "<p>En este seminario revisaremos los ejercicios vistos en esta unidad, lxs\ninstructorxs har&#xE1;n ejercicios guiados y respond&#xE1;n sus preguntas.</p>\n<h2 id=\"requisitos\">Requisitos</h2>\n<ul>\n<li>Haber completado ejercicios de higher order functions, aplicaci&#xF3;n parcial y\ncurrying.</li>\n</ul>\n"
          },
          "07-quiz": {
            "title": "Cuestionario",
            "type": "quiz",
            "format": "self-paced",
            "duration": 10,
            "questions": []
          },
          "08-closing": {
            "title": "Cierre",
            "type": "seminario",
            "format": "guiado",
            "duration": 15,
            "body": "<h3 id=\"resumen\">Resumen</h3>\n<p>...</p>\n<h3 id=\"respondamos-juntxs-las-preguntas-de-la-apertura\">Respondamos juntxs las preguntas de la apertura</h3>\n<p>...</p>\n<h3 id=\"auto-evaluaci-n\">Auto-evaluaci&#xF3;n</h3>\n<p>Tus instructorxs te compartir&#xE1;n un link al cuestionario de <em>auto evaliaci&#xF3;n</em>.\nEste cuestionario no es calificado.</p>\n"
          }
        }
      },
      "06-workshop": {
        "title": "Hacking: reemplazando iteración con recursión",
        "bonus": false,
        "description": "<p>La duración estimada de esta unidad es de <em>2h</em>.</p>\n",
        "parts": {
          "00-opening": {
            "title": "Apertura",
            "type": "seminario",
            "format": "guiado",
            "duration": 15
          },
          "01-refactoring": {
            "title": "Implementación por pares",
            "type": "taller",
            "format": "self-paced",
            "duration": 90
          },
          "02-closing": {
            "title": "Cierre",
            "type": "seminario",
            "format": "guiado",
            "duration": 15
          }
        }
      },
      "07-demos": {
        "title": "Code review + Demos de proyectos",
        "bonus": false,
        "description": "<p>Cada equipo (dos alumnas) tendrá 5 minutos para presentar su demo. La duración\nestimada de esta unidad es de <em>2h</em>.</p>\n",
        "parts": {
          "00-opening": {
            "title": "Apertura",
            "type": "seminario",
            "format": "guiado",
            "duration": 15
          },
          "02-closing": {
            "title": "Cierre",
            "type": "seminario",
            "format": "guiado",
            "duration": 15
          }
        }
      }
    },
    "grades": "<ul>\n<li><strong>Ejercicios</strong>: Durante el curso completarás varios ejercicios en el LMS.\nEstos ejercicios incluyen tests automatizados con la intención de dar feedback\nimmediato, pero los ejercicios en sí no serán calificados. Se elegirá uno o\ndos ejercicios junto con el proyecto para la sesión de <em>code review</em>, que sí\nserá calificada.</li>\n<li><strong>Cuestionarios</strong>: Al igual que los ejercicios, a lo largo del curso\nresponderás varios cuestionarios con feedback immediato, y éstos no cuentan\npara la nota final.</li>\n<li><strong>Proyecto</strong>: Antes de la sesión de <em>code review</em> y las demos, cada alumna\ndebe entregar (via pull request) el código de su proyecto. El proyecto incluye\nrefactorizar varios módulos de una base de código existente.</li>\n<li><strong>Code review</strong>: <strong>(50%)</strong> La última semana del curso tendrás una sesión de\n<em>code review</em> con uno de lxs instructorxs. En esta sesión se revisará el\ncódigo del proyecto así como uno o dos ejercicios realizados durante el curso.</li>\n<li><strong>Demo</strong>: <strong>(50%)</strong> El curso cerrará con una demo en la que tendrás que\npresentar al resto de la clase el trabajo realizado y lo aprendido en el\nproyecto.</li>\n</ul>\n",
    "contributors": "<ul>\n<li>Milton Mazzarri (autor)</li>\n<li>Lupo Montero (coordinador)</li>\n<li>Ana Rangel (colaboradora)</li>\n</ul>\n",
    "books": "<ul>\n<li><a href=\"http://shop.oreilly.com/product/0636920028857.do\">Functional JavaScript</a> de\nMichael Fogus</li>\n<li><a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a></li>\n</ul>\n",
    "benchmarks": "<p>Cursos similares que sirven como referencia:</p>\n<ul>\n<li><a href=\"http://shop.oreilly.com/product/0636920052463.do\">Introduction to Functional Programming</a>,\nHow to Think Functionally in (Almost) Any Language, Barry Burd, November 2016,\nO&#39;Reilly Media</li>\n</ul>\n",
    "references": "<p>Capítulos de libros:</p>\n<ul>\n<li><a href=\"http://eloquentjavascript.net/03_functions.html\">Eloquent JavaScript - Chapter 3: Functions</a></li>\n<li><a href=\"http://eloquentjavascript.net/05_higher_order.html\">Eloquent JavaScript - Chapter 5: Higher-Order Functions</a></li>\n</ul>\n<p>Blog posts:</p>\n<ul>\n<li><a href=\"https://medium.com/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257\">Why Learn Functional Programming in JavaScript? (Composing Software)</a>,\nEric Elliott en Medium, Feb 20 2017</li>\n<li><a href=\"https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0\">Master the JavaScript Interview: What is Functional Programming?</a>,\nEric Elliott en Medium, Jan 3 2017</li>\n<li><a href=\"https://medium.freecodecamp.com/functional-programming-in-js-with-practical-examples-part-1-87c2b0dbc276\">Functional Programming In JavaScript — With Practical Examples (Part 1)</a>,\nFree Code Camp, @rajaraodv, Nov 14 2016</li>\n<li><a href=\"https://bethallchurch.github.io/JavaScript-and-Functional-Programming/\">JavaScript and Functional Programming</a>,\nBeth Allchurch, 29 of June, 2016</li>\n<li><a href=\"https://codewords.recurse.com/issues/one/an-introduction-to-functional-programming\">An introduction to functional programming</a>,\nMary Rose Cook</li>\n<li><a href=\"https://medium.com/@y_kishino/functional-programming-in-javascript-part-2-78078df327a5\">Functional Programming in Javascript (Part 2)</a>\n<a href=\"https://medium.com/@y_kishino\">@yyyk</a>, Apr 16 2017 (needs review)</li>\n<li><a href=\"https://medium.com/@ryandrewjohnson/one-webpack-config-to-rule-them-all-environments-that-is-277457769779\">One webpack config to rule them all — environments that is</a>,\n<a href=\"https://medium.com/@ryandrewjohnson\">Ryan Johnson</a>, Feb 12 2017</li>\n<li><a href=\"https://medium.com/front-end-hacking/what-are-npm-yarn-babel-and-webpack-and-how-to-properly-use-them-d835a758f987\">What are NPM, Yarn, Babel, and Webpack; and how to properly use them?</a>,\n<a href=\"https://medium.com/@gasim.appristas\">Gasim Gasimzada</a>, May 9 2017 (needs review)</li>\n</ul>\n<p>Videos:</p>\n<ul>\n<li><a href=\"https://www.youtube.com/playlist?list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84\">Functional programming in JavaScript</a>,\nMattias Petter Johansson.</li>\n<li><a href=\"https://www.youtube.com/watch?v=e-5obm1G_FY\">Learning Functional Programming with JavaScript</a>,\nAnjana Vakil, JSUnconf 2016</li>\n<li><a href=\"https://www.youtube.com/watch?v=6Qx5ZAbfqjo\">Functional programming and curry cooking in JS</a>,\nStefanie Schirmer, JSConf EU 2015</li>\n<li><a href=\"http://2014.jsconf.eu/speakers/james-coglan-practical-functional-programming-pick-two.html\">Practical functional programming: pick two</a>,\nJames Coglan, JSConf EU 2014</li>\n<li><a href=\"https://vimeo.com/49384334\">Pure JavaScript</a>, Christian Johansen (@cjno), Sep\n13 2012</li>\n</ul>\n<p>Otros recursos:</p>\n<ul>\n<li><a href=\"https://github.com/hemanth/functional-programming-jargon\">Glosario de términos de programación funcional</a>,\n@hemanth en GitHub.</li>\n</ul>\n"
  }
}
